{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RenderCV","text":"<p>RenderCV is a Python application that creates a $\\LaTeX$ CV as a PDF from a JSON/YAML input file. Currently, it only supports one theme (classic). An example PDF can be seen here. More themes are planned to be supported in the future.</p> <p>What does it do?</p> <ul> <li>It parses a YAML (or JSON) file that looks like this: <pre><code>cv:\n  name: John Doe\n  label: Mechanical Engineer\n  location: Geneva, Switzerland\n  email: johndoe@example.com\n  phone: \"+33749882538\"\n  website: https://example.com\n  social_networks:\n    - network: GitHub\n      username: johndoe\n    - network: LinkedIn\n      username: johndoe\n  education:\n    - institution: My University\n      url: https://example.com\n      area: Mechanical Engineering\n      study_type: BS\n      location: Geneva, Switzerland\n      start_date: \"2017-09-01\"\n      end_date: \"2023-01-01\"\n      transcript_url: https://example.com\n      gpa: 3.10/4.00\n      highlights:\n        - \"Class rank: 10 of 62\"\n    - institution: The University of Texas at Austin\n      url: https://utexas.edu\n      area: Mechanical Engineering, Student Exchange Program\n      location: Austin, TX, USA\n      start_date: \"2021-08-01\"\n      end_date: \"2022-01-15\"\n  work_experience:\n    - company: AmIACompany\n      position: Summer Intern\n      location: Istanbul, Turkey\n      url: https://example.com\n      start_date: \"2022-06-15\"\n      end_date: \"2022-08-01\"\n      highlights:\n        - AmIACompany is a **technology** (markdown is\n          supported) company that provides web-based\n          engineering applications that enable the\n          simulation and optimization of products and\n          manufacturing tools.\n        - Modeled and simulated a metal-forming process deep\n          drawing using finite element analysis with\n          open-source software called CalculiX.\n</code></pre></li> <li>Then, it validates the input, such as checking if the dates are consistent, checking if the URLs are correct, etc.</li> <li>Then, it creates a $\\LaTeX$ file.</li> <li>Finally, it renders the $\\LaTeX$ file to generate the PDF, and you don't need $\\LaTeX$ installed on your PC because RenderCV comes with TinyTeX.</li> </ul> <p></p>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Install Python (3.10 or newer).</li> <li>Run the command below to install RenderCV.     <pre><code>pip install rendercv\n</code></pre></li> <li>Run the command below to generate a sample input file (<code>Full_Name_CV.yaml</code>). The file will be generated in the current working directory.     <pre><code>rendercv new \"Full Name\"\n</code></pre></li> <li>Edit the contents of the <code>Full_Name_CV.yaml</code> file.</li> <li>Run the command below to generate your $\\LaTeX$ CV.     <pre><code>rendercv render Full_Name_CV.yaml\n</code></pre></li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions to RenderCV are welcome, especially adding new $\\LaTeX$ themes.</p>"},{"location":"contact/","title":"Contact","text":"<p>test</p>"},{"location":"user_guide/","title":"RenderCV: User Guide","text":"<p>After you've installed RenderCV with</p> <pre><code>pip install rendercv\n</code></pre> <p>you can start rendering your CV.</p> <p>Firstly, go to the directory where you want your CV files located and run:</p> <pre><code>rendercv new \"Your Full Name\"\n</code></pre> <p>This will create a YAML input file for RenderCV called <code>Your_Name_CV.yaml</code>. Open this generated file in your favorite IDE and start editing. It governs all the features of RenderCV.</p> <p>Tip</p> <p>To maximize your productivity while editing the input YAML file, set up RenderCV's JSON Schema in your IDE. It will validate your inputs on the fly and give auto-complete suggestions.</p> Visual Studio CodeOther <ol> <li>Install YAML language support extension.</li> <li>Then the Schema will be automatically set up because the file ends with <code>_CV.yaml</code>.</li> </ol> <ol> <li>Ensure your editor of choice has support for YAML schema validation.</li> <li> <p>Add the following line at the top of <code>Your_Name_CV.yaml</code>:</p> <pre><code># yaml-language-server: $schema=https://github.com/sinaatalay/rendercv/blob/main/schema.json?raw=true\n</code></pre> </li> </ol> <p>After you're done editing your input file, run the command below to render your CV: <pre><code>rendercv render Your_Name_CV.yaml\n</code></pre></p>"},{"location":"user_guide/#entry-types","title":"Entry Types","text":"<p>There are five entry types in RenderCV:</p> <ol> <li>EducationEntry</li> <li>ExperienceEntry</li> <li>NormalEntry</li> <li>OneLineEntry</li> <li>PublicationEntry</li> </ol> <p>The whole CV consists of these entries. The table below shows what sections of the input file use which entry type.</p> YAML section Entry Type <code>education</code> EducationEntry <code>work_experience</code> ExperienceEntry <code>academic_projects</code> NormalEntry <code>publications</code> PublicationEntry <code>certificates</code> NormalEntry <code>skills</code> OneLineEntry <code>test_scores</code> OneLineEntry <code>personal_projects</code> NormalEntry <code>extracurricular_activities</code> ExperienceEntry <code>custom_sections</code> They can be any of the five! <p>Info</p> <p>Note that EducationEntry is not necessarily for education entries only. It's one of the five entry designs that RenderCV offers, and it could be used for anything (see custom sections). EducationEntry just happens to be its name. The same goes for other entries, too.</p>"},{"location":"user_guide/#educationentry","title":"EducationEntry","text":"<pre><code>institution: Bo\u011fazi\u00e7i University\nurl: https://boun.edu.tr\narea: Mechanical Engineering\nstudy_type: BS\nlocation: Istanbul, Turkey\nstart_date: \"2017-09-01\"\nend_date: \"2023-01-01\"\ntranscript_url: https://example.com\ngpa: 3.10/4.00\nhighlights:\n- \"Class rank: 10 of 62\"\n</code></pre> <p>which renders into</p> <p></p>"},{"location":"user_guide/#experienceentry","title":"ExperienceEntry","text":"<pre><code>company: AmIACompany\nposition: Summer Intern\nlocation: Istanbul, Turkey\nurl: https://example.com\nstart_date: \"2022-06-15\"\nend_date: \"2022-08-01\"\nhighlights:\n- AmIACompany is a technology company that provides web-based engineering\n  applications that enable the simulation and optimization of products and\n  manufacturing tools.\n- Modeled and simulated a metal-forming process deep drawing using finite element\n  analysis with open-source software called CalculiX.\n</code></pre> <p>which renders into</p> <p></p>"},{"location":"user_guide/#normalentry","title":"NormalEntry","text":"<pre><code>name: Design and Construction of a Dynamometer\nlocation: Istanbul, Turkey\ndate: Fall 2022\nhighlights:\n- Designed and constructed a controllable dynamometer that measures an electric\n  motor's torque and power output at different speeds for my senior design project.\nurl: https://example.com\n</code></pre> <p>which renders into</p> <p></p>"},{"location":"user_guide/#onelineentry","title":"OneLineEntry","text":"<pre><code>name: Programming\ndetails: C++, C, Python, JavaScript, MATLAB, Lua, LaTeX\n</code></pre> <p>which renders into</p> <p></p>"},{"location":"user_guide/#publicationentry","title":"PublicationEntry","text":"<pre><code>title: Phononic band gaps induced by inertial amplification in periodic media\nauthors:\n- Author 1\n- John Doe\n- Author 3\njournal: Physical Review B\ndoi: 10.1103/PhysRevB.76.054309\ndate: \"2007-08-01\"\ncited_by: 243\n</code></pre> <p>which renders into</p> <p></p>"},{"location":"user_guide/#custom-sections","title":"Custom Sections","text":"<p>Custom sections with custom titles can be created. Each custom section will be an object that looks like this:</p> <pre><code>title: My Custom Section\nentry_type: OneLineEntry\nentries:\n- name: Testing custom sections\n  details: Wohooo!\n- name: This is a\n  details: OneLineEntry!\n</code></pre> <p>And <code>custom_sections</code> part of the data model will be a list of customs section objects that look like this: <pre><code>custom_sections:\n- title: My Custom Section\n  entry_type: OneLineEntry\n  entries:\n    - name: Testing custom sections\n      details: Wohooo!\n    - name: This is a\n      details: OneLineEntry!\n- title: My Other Custom Section\n  entry_type: EducationEntry\n  entries:\n    - institution: Hop!\n      area: Hop!\n      study_type: HA\n      highlights:\n      - \"There are only five types of entries: *EducationEntry*, *ExperienceEntry*,\n        *NormalEntry*, *OneLineEntry*, and *PublicationEntry*.\"\n      - This is an EducationEntry!\n      start_date: \"2022-06-15\"\n      end_date: \"2022-08-01\"\n</code></pre></p> <p>Each custom section needs to have an entry type, and entries should be adjusted according to the entry type selection.</p> <p>Note</p> <p>Some entry types use links, and all the links have a text placeholder. That placeholder can be changed with <code>link_text</code> setting as shown below: <pre><code>title: My Third Custom Section\nentry_type: ExperienceEntry\nlink_text: My Link Text\nentries:\n- company: Hop!\n  position: Hop!\n  date: My Date\n  location: My Location\n  url: https://example.com\n  highlights:\n  - I think this is really working. This is an *ExperienceEntry*!\n</code></pre></p>"},{"location":"api_reference/","title":"RenderCV","text":"<p>RenderCV package.</p> <p>It parses the user input YAML/JSON file and validates the data (checks if the dates are consistent, if the URLs are valid, etc.). Then, with the data, it creates a $\\LaTeX$ file and renders it with TinyTeX.</p> <p>In this section, you can find how RenderCV works in detail.</p> <p>Modules:</p> <ul> <li>__main__ \u2013 This module contains the main functions of RenderCV.</li> <li>data_model \u2013 This module contains classes and functions to parse RenderCV's specifically structured YAML or JSON to generate meaningful data for Python.</li> <li>rendering \u2013 This module implements $\\LaTeX$ file generation and $\\LaTeX$ runner utilities for RenderCV.</li> </ul>"},{"location":"api_reference/__main__/","title":"__main___","text":""},{"location":"api_reference/__main__/#rendercv.__main__.user_friendly_errors","title":"<code>user_friendly_errors(func)</code>","text":"<p>Function decorator to make RenderCV's error messages more user-friendly.</p> <p>Parameters:</p> <ul> <li> <code>func</code>             (<code>Callable</code>)         \u2013          <p>Function to decorate</p> </li> </ul> <p>Returns:     Callable: Decorated function</p> Source code in <code>rendercv/__main__.py</code> <pre><code>def user_friendly_errors(func: Callable) -&gt; Callable:\n    \"\"\"Function decorator to make RenderCV's error messages more user-friendly.\n\n    Args:\n        func (Callable): Function to decorate\n    Returns:\n        Callable: Decorated function\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            func(*args, **kwargs)\n        except ValidationError as e:\n            # It is a Pydantic error\n            error_messages = []\n            error_messages.append(\"There are some problems with your input.\")\n\n            # Translate Pydantic's error messages to make them more user-friendly\n            custom_error_messages_by_type = {\n                \"url_scheme\": \"This is not a valid URL.\",\n                \"string_type\": \"This is not a valid string.\",\n                \"missing\": \"This field is required, but it is missing.\",\n                \"literal_error\": \"Only the following values are allowed: {expected}.\",\n            }\n            custom_error_messages_by_msg = {\n                \"value is not a valid phone number\": (\n                    \"This is not a valid phone number.\"\n                ),\n                \"String should match pattern '\\\\d+\\\\.?\\\\d* *(cm|in|pt|mm|ex|em)'\": (\n                    \"This is not a valid length! Use a number followed by a unit \"\n                    \"of length (cm, in, pt, mm, ex, em).\"\n                ),\n            }\n            new_errors: list[ErrorDetails] = []\n            for error in e.errors():\n                # Modify Pydantic's error message to make it more user-friendly\n\n                # Remove url:\n                error[\"url\"] = None\n\n                # Make sure the entries of loc (location) are strings\n                error[\"loc\"] = [str(loc) for loc in error[\"loc\"]]\n\n                # Assign a custom error message if there is one\n                custom_message = None\n                if error[\"type\"] in custom_error_messages_by_type:\n                    custom_message = custom_error_messages_by_type[error[\"type\"]]\n                elif error[\"msg\"] in custom_error_messages_by_msg:\n                    custom_message = custom_error_messages_by_msg[error[\"msg\"]]\n\n                if custom_message:\n                    ctx = error.get(\"ctx\")\n                    ctx_error = ctx.get(\"error\") if ctx else None\n                    if ctx_error:\n                        # This means that there is a custom validation error that\n                        # comes from data_model.py\n                        error[\"msg\"] = ctx[\"error\"].args[0]\n                    elif ctx:\n                        # Some Pydantic errors have a context, see the custom message\n                        # for \"literal_error\" above\n                        error[\"msg\"] = custom_message.format(**ctx)\n                    else:\n                        # If there is no context, just use the custom message\n                        error[\"msg\"] = custom_message\n\n                if error[\"input\"] is not None:\n                    # If the input value is a dictionary, remove it\n                    if isinstance(error[\"input\"], dict):\n                        error[\"input\"] = None\n                    elif isinstance(error[\"input\"], (float, int, bool, str)):\n                        # Or if the input value is in the error message, remove it\n                        input_value = str(error[\"input\"])\n                        if input_value in error[\"msg\"]:\n                            error[\"input\"] = None\n\n                new_errors.append(error)\n\n            # Create a custom error message for RenderCV users\n            for error in new_errors:\n                if len(error[\"loc\"]) &gt; 0:\n                    location = \".\".join(error[\"loc\"])\n                    error_messages.append(f\"{location}:\\n    {error['msg']}\")\n                else:\n                    error_messages.append(f\"{error['msg']}\")\n\n                if error[\"input\"]:\n                    error_messages[-1] += f\"\\n    Your input was \\\"{error['input']}\\\"\"\n            error_message = \"\\n\\n  \".join(error_messages)\n            logger.error(error_message)\n\n        except ParserError as e:\n            # It is a YAML parser error\n            new_args = list(e.args)\n            new_args = [str(arg).strip() for arg in new_args]\n            new_args[0] = \"There is a problem with your input file.\u200d\"\n            error_message = \"\\n\\n  \".join(new_args)\n            logger.error(error_message)\n\n        except Exception as e:\n            # It is not a Pydantic error\n            new_args = list(e.args)\n            new_args = [str(arg).strip() for arg in new_args]\n            error_message = \"\\n\\n  \".join(new_args)\n            logger.error(error_message)\n\n    return wrapper\n</code></pre>"},{"location":"api_reference/__main__/#rendercv.__main__.render_cv","title":"<code>render_cv(input_file)</code>","text":"<p>Generate a LaTeX CV from a YAML input file.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str</code>)         \u2013          <p>Name of the YAML input file</p> </li> </ul> Source code in <code>rendercv/__main__.py</code> <pre><code>@app.command(help=\"Render CV\")\n@user_friendly_errors\ndef render_cv(\n        input_file: Annotated[\n            str,\n            typer.Argument(help=\"Name of the YAML input file\"),\n        ]\n):\n    \"\"\"Generate a LaTeX CV from a YAML input file.\n\n    Args:\n        input_file (str): Name of the YAML input file\n    \"\"\"\n    file_path = os.path.abspath(input_file)\n    data = read_input_file(file_path)\n    output_latex_file = render_template(data, template=\"cv\", suffix=\"CV\")\n    run_latex(output_latex_file)\n</code></pre>"},{"location":"api_reference/__main__/#rendercv.__main__.render_cover_letter","title":"<code>render_cover_letter(input_file)</code>","text":"<p>Generate a LaTeX cover letter from a YAML input file.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>             (<code>str</code>)         \u2013          <p>Name of the YAML input file</p> </li> </ul> Source code in <code>rendercv/__main__.py</code> <pre><code>@app.command(help=\"Render cover letter\")\n@user_friendly_errors\ndef render_cover_letter(\n        input_file: Annotated[\n            str,\n            typer.Argument(help=\"Name of the YAML input file\"),\n        ]\n):\n    \"\"\"Generate a LaTeX cover letter from a YAML input file.\n\n    Args:\n        input_file (str): Name of the YAML input file\n    \"\"\"\n    file_path = os.path.abspath(input_file)\n    data = read_input_file(file_path)\n    output_latex_file = render_template(data, template=\"cover_letter\", suffix=\"cover_letter\")\n    run_latex(output_latex_file)\n</code></pre>"},{"location":"api_reference/__main__/#rendercv.__main__.new","title":"<code>new(name)</code>","text":"<p>Generate a YAML input file to get started.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Full name</p> </li> </ul> Source code in <code>rendercv/__main__.py</code> <pre><code>@app.command(help=\"Generate a YAML input file to get started\")\n@user_friendly_errors\ndef new(name: Annotated[str, typer.Argument(help=\"Full name\")]):\n    \"\"\"Generate a YAML input file to get started.\n\n    Args:\n        name (str): Full name\n    \"\"\"\n    environment = Environment(\n        loader=PackageLoader(\"rendercv\", os.path.join(\"templates\")),\n    )\n    environment.variable_start_string = \"&lt;&lt;\"\n    environment.variable_end_string = \"&gt;&gt;\"\n\n    template = environment.get_template(\"new_input.yaml.j2\")\n    new_input_file = template.render(name=name)\n\n    name = name.replace(\" \", \"_\")\n    file_name = f\"{name}_CV.yaml\"\n    with open(file_name, \"w\", encoding=\"utf-8\") as file:\n        file.write(new_input_file)\n\n    logger.info(f\"New input file created: {file_name}\")\n</code></pre>"},{"location":"api_reference/__main__/#rendercv.__main__.cli","title":"<code>cli()</code>","text":"<p>Start the CLI application.</p> <p>This function is the entry point for RenderCV.</p> Source code in <code>rendercv/__main__.py</code> <pre><code>def cli():\n    \"\"\"Start the CLI application.\n\n    This function is the entry point for RenderCV.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"api_reference/data_model/","title":"Data Model","text":"<p>This module contains classes and functions to parse and validate YAML or JSON input files. It uses Pydantic to achieve this goal. All the data classes have <code>BaseModel</code> from Pydantic as a base class, and some data fields have advanced types like <code>HttpUrl</code>, <code>EmailStr</code>, or <code>PastDate</code> from the Pydantic library for validation.</p>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemePageMargins","title":"<code>ClassicThemePageMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins of pages for the classic theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemePageMargins(BaseModel):\n    \"\"\"This class stores the margins of pages for the classic theme.\"\"\"\n\n    top: LaTeXDimension = Field(\n        default=\"2 cm\",\n        title=\"Top Margin\",\n        description=\"The top margin of the page with units.\",\n    )\n    bottom: LaTeXDimension = Field(\n        default=\"2 cm\",\n        title=\"Bottom Margin\",\n        description=\"The bottom margin of the page with units.\",\n    )\n    left: LaTeXDimension = Field(\n        default=\"1.24 cm\",\n        title=\"Left Margin\",\n        description=\"The left margin of the page with units.\",\n    )\n    right: LaTeXDimension = Field(\n        default=\"1.24 cm\",\n        title=\"Right Margin\",\n        description=\"The right margin of the page with units.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeSectionTitleMargins","title":"<code>ClassicThemeSectionTitleMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins of section titles for the classic theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeSectionTitleMargins(BaseModel):\n    \"\"\"This class stores the margins of section titles for the classic theme.\"\"\"\n\n    top: LaTeXDimension = Field(\n        default=\"0.2 cm\",\n        title=\"Top Margin\",\n        description=\"The top margin of section titles.\",\n    )\n    bottom: LaTeXDimension = Field(\n        default=\"0.2 cm\",\n        title=\"Bottom Margin\",\n        description=\"The bottom margin of section titles.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeEntryAreaMargins","title":"<code>ClassicThemeEntryAreaMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins of entry areas for the classic theme.</p> <p>For the classic theme, entry areas are OneLineEntry, NormalEntry, and ExperienceEntry.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeEntryAreaMargins(BaseModel):\n    \"\"\"This class stores the margins of entry areas for the classic theme.\n\n    For the classic theme, entry areas are [OneLineEntry](../user_guide.md#onelineentry),\n    [NormalEntry](../user_guide.md#normalentry), and\n    [ExperienceEntry](../user_guide.md#experienceentry).\n    \"\"\"\n\n    left_and_right: LaTeXDimension = Field(\n        default=\"0.2 cm\",\n        title=\"Left Margin\",\n        description=\"The left margin of entry areas.\",\n    )\n\n    vertical_between: LaTeXDimension = Field(\n        default=\"0.12 cm\",\n        title=\"Vertical Margin Between Entry Areas\",\n        description=\"The vertical margin between entry areas.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeHighlightsAreaMargins","title":"<code>ClassicThemeHighlightsAreaMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins of highlights areas for the classic theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeHighlightsAreaMargins(BaseModel):\n    \"\"\"This class stores the margins of highlights areas for the classic theme.\"\"\"\n\n    top: LaTeXDimension = Field(\n        default=\"0.10 cm\",\n        title=\"Top Margin\",\n        description=\"The top margin of highlights areas.\",\n    )\n    left: LaTeXDimension = Field(\n        default=\"0.4 cm\",\n        title=\"Left Margin\",\n        description=\"The left margin of highlights areas.\",\n    )\n    vertical_between_bullet_points: LaTeXDimension = Field(\n        default=\"0.10 cm\",\n        title=\"Vertical Margin Between Bullet Points\",\n        description=\"The vertical margin between bullet points.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeHeaderMargins","title":"<code>ClassicThemeHeaderMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins of the header for the classic theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeHeaderMargins(BaseModel):\n    \"\"\"This class stores the margins of the header for the classic theme.\"\"\"\n\n    vertical_between_name_and_connections: LaTeXDimension = Field(\n        default=\"0.2 cm\",\n        title=\"Vertical Margin Between the Name and Connections\",\n        description=(\n            \"The vertical margin between the name of the person and the connections.\"\n        ),\n    )\n    bottom: LaTeXDimension = Field(\n        default=\"0.2 cm\",\n        title=\"Bottom Margin\",\n        description=(\n            \"The bottom margin of the header, i.e., the vertical margin between the\"\n            \" connections and the first section title.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeMargins","title":"<code>ClassicThemeMargins</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the margins for the classic theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeMargins(BaseModel):\n    \"\"\"This class stores the margins for the classic theme.\"\"\"\n\n    page: ClassicThemePageMargins = Field(\n        default=ClassicThemePageMargins(),\n        title=\"Page Margins\",\n        description=\"Page margins for the classic theme.\",\n    )\n    section_title: ClassicThemeSectionTitleMargins = Field(\n        default=ClassicThemeSectionTitleMargins(),\n        title=\"Section Title Margins\",\n        description=\"Section title margins for the classic theme.\",\n    )\n    entry_area: ClassicThemeEntryAreaMargins = Field(\n        default=ClassicThemeEntryAreaMargins(),\n        title=\"Entry Area Margins\",\n        description=\"Entry area margins for the classic theme.\",\n    )\n    highlights_area: ClassicThemeHighlightsAreaMargins = Field(\n        default=ClassicThemeHighlightsAreaMargins(),\n        title=\"Highlights Area Margins\",\n        description=\"Highlights area margins for the classic theme.\",\n    )\n    header: ClassicThemeHeaderMargins = Field(\n        default=ClassicThemeHeaderMargins(),\n        title=\"Header Margins\",\n        description=\"Header margins for the classic theme.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ClassicThemeOptions","title":"<code>ClassicThemeOptions</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the options for the classic theme.</p> <p>In RenderCV, each theme has its own Pydantic class so that new themes can be implemented easily in future.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ClassicThemeOptions(BaseModel):\n    \"\"\"This class stores the options for the classic theme.\n\n    In RenderCV, each theme has its own Pydantic class so that new themes\n    can be implemented easily in future.\n    \"\"\"\n\n    primary_color: Color = Field(\n        default=\"rgb(0,79,144)\",\n        validate_default=True,\n        title=\"Primary Color\",\n        description=(\n            \"The primary color of Classic Theme. It is used for the section titles,\"\n            \" heading, and the links.\\nThe color can be specified either with their\"\n            \" [name](https://www.w3.org/TR/SVG11/types.html#ColorKeywords), hexadecimal\"\n            \" value, RGB value, or HSL value.\"\n        ),\n        examples=[\"Black\", \"7fffd4\", \"rgb(0,79,144)\", \"hsl(270, 60%, 70%)\"],\n    )\n\n    date_and_location_width: LaTeXDimension = Field(\n        default=\"4.1 cm\",\n        title=\"Date and Location Column Width\",\n        description=\"The width of the date and location column.\",\n    )\n\n    text_alignment: Literal[\"left-aligned\", \"justified\"] = Field(\n        default=\"left-aligned\",\n        title=\"Text Alignment\",\n        description=\"The alignment of the text.\",\n    )\n\n    show_timespan_in: list[str] = Field(\n        default=[],\n        title=\"Show Time Span in These Sections\",\n        description=(\n            \"The time span will be shown in the date and location column in these\"\n            \" sections. The input should be a list of strings.\"\n        ),\n    )\n\n    show_last_updated_date: bool = Field(\n        default=True,\n        title=\"Show Last Updated Date\",\n        description=(\n            \"If this option is set to true, then the last updated date will be shown\"\n            \" in the header.\"\n        ),\n    )\n\n    header_font_size: LaTeXDimension = Field(\n        default=\"30 pt\",\n        title=\"Header Font Size\",\n        description=\"The font size of the header (the name of the person).\",\n    )\n\n    margins: ClassicThemeMargins = Field(\n        default=ClassicThemeMargins(),\n        title=\"Margins\",\n        description=\"Page, section title, entry field, and highlights field margins.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Design","title":"<code>Design</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores the theme name of the CV and the theme's options.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class Design(BaseModel):\n    \"\"\"This class stores the theme name of the CV and the theme's options.\"\"\"\n\n    theme: Literal[\"classic\"] = Field(\n        default=\"classic\",\n        title=\"Theme name\",\n        description='The only option is \"Classic\" for now.',\n    )\n    font: Literal[\"SourceSans3\", \"Roboto\", \"EBGaramond\"] = Field(\n        default=\"SourceSans3\",\n        title=\"Font\",\n        description=\"The font of the CV.\",\n    )\n    font_size: Literal[\"10pt\", \"11pt\", \"12pt\"] = Field(\n        default=\"10pt\",\n        title=\"Font Size\",\n        description=\"The font size of the CV. It can be 10pt, 11pt, or 12pt.\",\n    )\n    page_size: Literal[\"a4paper\", \"letterpaper\"] = Field(\n        default=\"a4paper\",\n        title=\"Page Size\",\n        description=\"The page size of the CV. It can be a4paper or letterpaper.\",\n    )\n    options: Optional[ClassicThemeOptions] = Field(\n        default=None,\n        title=\"Theme Options\",\n        description=\"The options of the theme.\",\n    )\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def check_theme_options(cls, model):\n        \"\"\"Check if the correct options are provided for the theme. If the theme\n        options are not provided, then set the default options for the theme.\n        \"\"\"\n        if model.options is None:\n            if model.theme == \"classic\":\n                model.options = ClassicThemeOptions()\n            else:\n                raise RuntimeError(f'The theme \"{model.theme}\" does not exist.')\n        else:\n            if model.theme == \"classic\":\n                if not isinstance(model.options, ClassicThemeOptions):\n                    raise ValueError(\n                        \"Theme is classic but options is not classic theme options.\"\n                    )\n            else:\n                raise RuntimeError(f'The theme \"{model.theme}\"\" does not exist.')\n\n        return model\n\n    @field_validator(\"font\")\n    @classmethod\n    def check_font(cls, font: str) -&gt; str:\n        \"\"\"Go to the fonts directory and check if the font exists. If it exists, then\n        check if all the required files are there.\n        \"\"\"\n        fonts_directory = str(files(\"rendercv\").joinpath(\"templates\", \"fonts\"))\n        if font not in os.listdir(fonts_directory):\n            raise ValueError(\n                f'The font \"{font}\" is not found in the \"fonts\" directory.'\n            )\n        else:\n            font_directory = os.path.join(fonts_directory, font)\n            required_files = [\n                f\"{font}-Bold.ttf\",\n                f\"{font}-BoldItalic.ttf\",\n                f\"{font}-Italic.ttf\",\n                f\"{font}-Regular.ttf\",\n            ]\n            for file in required_files:\n                if file not in os.listdir(font_directory):\n                    raise ValueError(f\"{file} is not found in the {font} directory.\")\n\n        return font\n\n    @field_validator(\"theme\")\n    @classmethod\n    def check_if_theme_exists(cls, theme: str) -&gt; str:\n        \"\"\"Check if the theme exists in the templates directory.\"\"\"\n        cv_template_directory = str(files(\"rendercv\").joinpath(\"templates\", theme, \"cv\"))\n        cover_letter_template_directory = str(files(\"rendercv\").joinpath(\"templates\", theme, \"cover_letter\"))\n        if f\"{theme}.tex.j2\" not in os.listdir(cv_template_directory) \\\n                or f\"{theme}.tex.j2\" not in os.listdir(cover_letter_template_directory):\n            raise ValueError(\n                f'The theme \"{theme}\" is not found in the \"templates\" directory.'\n            )\n\n        return theme\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Design.check_theme_options","title":"<code>check_theme_options(model)</code>  <code>classmethod</code>","text":"<p>Check if the correct options are provided for the theme. If the theme options are not provided, then set the default options for the theme.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@model_validator(mode=\"after\")\n@classmethod\ndef check_theme_options(cls, model):\n    \"\"\"Check if the correct options are provided for the theme. If the theme\n    options are not provided, then set the default options for the theme.\n    \"\"\"\n    if model.options is None:\n        if model.theme == \"classic\":\n            model.options = ClassicThemeOptions()\n        else:\n            raise RuntimeError(f'The theme \"{model.theme}\" does not exist.')\n    else:\n        if model.theme == \"classic\":\n            if not isinstance(model.options, ClassicThemeOptions):\n                raise ValueError(\n                    \"Theme is classic but options is not classic theme options.\"\n                )\n        else:\n            raise RuntimeError(f'The theme \"{model.theme}\"\" does not exist.')\n\n    return model\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Design.check_font","title":"<code>check_font(font)</code>  <code>classmethod</code>","text":"<p>Go to the fonts directory and check if the font exists. If it exists, then check if all the required files are there.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@field_validator(\"font\")\n@classmethod\ndef check_font(cls, font: str) -&gt; str:\n    \"\"\"Go to the fonts directory and check if the font exists. If it exists, then\n    check if all the required files are there.\n    \"\"\"\n    fonts_directory = str(files(\"rendercv\").joinpath(\"templates\", \"fonts\"))\n    if font not in os.listdir(fonts_directory):\n        raise ValueError(\n            f'The font \"{font}\" is not found in the \"fonts\" directory.'\n        )\n    else:\n        font_directory = os.path.join(fonts_directory, font)\n        required_files = [\n            f\"{font}-Bold.ttf\",\n            f\"{font}-BoldItalic.ttf\",\n            f\"{font}-Italic.ttf\",\n            f\"{font}-Regular.ttf\",\n        ]\n        for file in required_files:\n            if file not in os.listdir(font_directory):\n                raise ValueError(f\"{file} is not found in the {font} directory.\")\n\n    return font\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Design.check_if_theme_exists","title":"<code>check_if_theme_exists(theme)</code>  <code>classmethod</code>","text":"<p>Check if the theme exists in the templates directory.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@field_validator(\"theme\")\n@classmethod\ndef check_if_theme_exists(cls, theme: str) -&gt; str:\n    \"\"\"Check if the theme exists in the templates directory.\"\"\"\n    cv_template_directory = str(files(\"rendercv\").joinpath(\"templates\", theme, \"cv\"))\n    cover_letter_template_directory = str(files(\"rendercv\").joinpath(\"templates\", theme, \"cover_letter\"))\n    if f\"{theme}.tex.j2\" not in os.listdir(cv_template_directory) \\\n            or f\"{theme}.tex.j2\" not in os.listdir(cover_letter_template_directory):\n        raise ValueError(\n            f'The theme \"{theme}\" is not found in the \"templates\" directory.'\n        )\n\n    return theme\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Event","title":"<code>Event</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class is the parent class for classes like <code>EducationEntry</code>, <code>ExperienceEntry</code>, <code>NormalEntry</code>, and <code>OneLineEntry</code>.</p> <p>It stores the common fields between these classes like dates, location, highlights, and URL.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class Event(BaseModel):\n    \"\"\"This class is the parent class for classes like `#!python EducationEntry`,\n    `#!python ExperienceEntry`, `#!python NormalEntry`, and `#!python OneLineEntry`.\n\n    It stores the common fields between these classes like dates, location, highlights,\n    and URL.\n    \"\"\"\n\n    start_date: Optional[PastDate] = Field(\n        default=None,\n        title=\"Start Date\",\n        description=\"The start date of the event in YYYY-MM-DD format.\",\n        examples=[\"2020-09-24\"],\n    )\n    end_date: Optional[Literal[\"present\"] | PastDate] = Field(\n        default=None,\n        title=\"End Date\",\n        description=(\n            \"The end date of the event in YYYY-MM-DD format. If the event is still\"\n            ' ongoing, then the value should be \"present\".'\n        ),\n        examples=[\"2020-09-24\", \"present\"],\n    )\n    date: Optional[PastDate | LaTeXString] = Field(\n        default=None,\n        title=\"Date\",\n        description=(\n            \"If the event is a one-day event, then this field should be filled in\"\n            \" YYYY-MM-DD format. If the event is a multi-day event, then the start date\"\n            \" and end date should be provided instead. All of them can't be provided at\"\n            \" the same time.\"\n        ),\n        examples=[\"2020-09-24\", \"My Custom Date\"],\n    )\n    highlights: Optional[list[LaTeXString]] = Field(\n        default=[],\n        title=\"Highlights\",\n        description=(\n            \"The highlights of the event. It will be rendered as bullet points.\"\n        ),\n        examples=[\"Did this.\", \"Did that.\"],\n    )\n    location: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Location\",\n        description=(\n            \"The location of the event. It will be shown with the date in the\"\n            \" same column.\"\n        ),\n        examples=[\"Istanbul, Turkey\"],\n    )\n    url: Optional[HttpUrl] = None\n\n    @field_validator(\"date\")\n    @classmethod\n    def check_date(cls, date: PastDate | LaTeXString) -&gt; PastDate | LaTeXString:\n        \"\"\"Check if the date is a string or a Date object and return accordingly.\"\"\"\n        if isinstance(date, str):\n            try:\n                # If this runs, it means the date is an ISO format string, and it can be\n                # parsed\n                date = parse_date_string(date)\n            except ValueError:\n                # Then it means it is a custom string like \"Fall 2023\"\n                date = date\n\n        return date\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def check_dates(cls, model):\n        \"\"\"Make sure that either `#!python start_date` and `#!python end_date` or only\n        `#!python date` is provided.\n        \"\"\"\n        date_is_provided = False\n        start_date_is_provided = False\n        end_date_is_provided = False\n        if model.date is not None:\n            date_is_provided = True\n        if model.start_date is not None:\n            start_date_is_provided = True\n        if model.end_date is not None:\n            end_date_is_provided = True\n\n        if date_is_provided and start_date_is_provided and end_date_is_provided:\n            logger.warning(\n                '\"start_date\", \"end_date\" and \"date\" are all provided in of the'\n                \" entries. Therefore, date will be ignored.\"\n            )\n            model.date = None\n\n        elif date_is_provided and start_date_is_provided and not end_date_is_provided:\n            logger.warning(\n                'Both \"date\" and \"start_date\" is provided in of the entries.'\n                ' \"start_date\" will be ignored.'\n            )\n            model.start_date = None\n            model.end_date = None\n\n        elif date_is_provided and end_date_is_provided and not start_date_is_provided:\n            logger.warning(\n                'Both \"date\" and \"end_date\" is provided in of the entries. \"end_date\"'\n                \" will be ignored.\"\n            )\n            model.start_date = None\n            model.end_date = None\n\n        elif start_date_is_provided and not end_date_is_provided:\n            logger.warning(\n                '\"start_date\" is provided in of the entries, but \"end_date\" is not.'\n                ' \"end_date\" will be set to \"present\".'\n            )\n            model.end_date = \"present\"\n\n        if model.start_date is not None and model.end_date is not None:\n            if model.end_date == \"present\":\n                end_date = Date.today()\n            elif isinstance(model.end_date, int):\n                # Then it means user only provided the year, so convert it to a Date\n                # object with the first day of the year (just for the date comparison)\n                end_date = Date(model.end_date, 1, 1)\n            elif isinstance(model.end_date, Date):\n                # Then it means user provided either YYYY-MM-DD or YYYY-MM\n                end_date = model.end_date\n            else:\n                raise RuntimeError(\"end_date is neither an integer nor a Date object.\")\n\n            if isinstance(model.start_date, int):\n                # Then it means user only provided the year, so convert it to a Date\n                # object with the first day of the year (just for the date comparison)\n                start_date = Date(model.start_date, 1, 1)\n            elif isinstance(model.start_date, Date):\n                # Then it means user provided either YYYY-MM-DD or YYYY-MM\n                start_date = model.start_date\n            else:\n                raise RuntimeError(\n                    \"start_date is neither an integer nor a Date object.\"\n                )\n\n            if start_date &gt; end_date:\n                raise ValueError(\n                    '\"start_date\" can not be after \"end_date\". Please check the dates.'\n                )\n\n        return model\n\n    @computed_field\n    @cached_property\n    def date_and_location_strings_with_timespan(self) -&gt; list[LaTeXString]:\n        date_and_location_strings = []\n\n        if self.location is not None:\n            date_and_location_strings.append(self.location)\n\n        if self.date is not None:\n            if isinstance(self.date, str):\n                date_and_location_strings.append(self.date)\n            elif isinstance(self.date, Date):\n                date_and_location_strings.append(format_date(self.date))\n            else:\n                raise RuntimeError(\"Date is neither a string nor a Date object.\")\n        elif self.start_date is not None and self.end_date is not None:\n            start_date = format_date(self.start_date)\n\n            if self.end_date == \"present\":\n                end_date = \"present\"\n\n                time_span_string = compute_time_span_string(\n                    self.start_date, Date.today()\n                )\n            else:\n                end_date = format_date(self.end_date)\n\n                time_span_string = compute_time_span_string(\n                    self.start_date, self.end_date\n                )\n\n            date_and_location_strings.append(f\"{start_date} to {end_date}\")\n\n            date_and_location_strings.append(f\"{time_span_string}\")\n\n        return date_and_location_strings\n\n    @computed_field\n    @cached_property\n    def date_and_location_strings_without_timespan(self) -&gt; list[LaTeXString]:\n        # use copy() to avoid modifying the original list\n        date_and_location_strings = self.date_and_location_strings_with_timespan.copy()\n        for string in date_and_location_strings:\n            if (\n                    \"years\" in string\n                    or \"months\" in string\n                    or \"year\" in string\n                    or \"month\" in string\n            ):\n                date_and_location_strings.remove(string)\n\n        return date_and_location_strings\n\n    @computed_field\n    @cached_property\n    def highlight_strings(self) -&gt; list[LaTeXString]:\n        highlight_strings = []\n        if self.highlights is not None:\n            highlight_strings.extend(self.highlights)\n\n        return highlight_strings\n\n    @computed_field\n    @cached_property\n    def markdown_url(self) -&gt; Optional[str]:\n        if self.url is None:\n            return None\n        else:\n            url = str(self.url)\n\n            if \"github\" in url:\n                link_text = \"view on GitHub\"\n            elif \"linkedin\" in url:\n                link_text = \"view on LinkedIn\"\n            elif \"instagram\" in url:\n                link_text = \"view on Instagram\"\n            elif \"youtube\" in url:\n                link_text = \"view on YouTube\"\n            else:\n                link_text = \"view on my website\"\n\n            markdown_url = f\"[{link_text}]({url})\"\n\n            return markdown_url\n\n    @computed_field\n    @cached_property\n    def month_and_year(self) -&gt; Optional[LaTeXString]:\n        if self.date is not None:\n            # Then it means start_date and end_date are not provided.\n            try:\n                # If this runs, it means the date is an ISO format string, and it can be\n                # parsed\n                month_and_year = format_date(self.date)  # type: ignore\n            except TypeError:\n                month_and_year = str(self.date)\n        else:\n            # Then it means start_date and end_date are provided and month_and_year\n            # doesn't make sense.\n            month_and_year = None\n\n        return month_and_year\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Event.check_date","title":"<code>check_date(date)</code>  <code>classmethod</code>","text":"<p>Check if the date is a string or a Date object and return accordingly.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@field_validator(\"date\")\n@classmethod\ndef check_date(cls, date: PastDate | LaTeXString) -&gt; PastDate | LaTeXString:\n    \"\"\"Check if the date is a string or a Date object and return accordingly.\"\"\"\n    if isinstance(date, str):\n        try:\n            # If this runs, it means the date is an ISO format string, and it can be\n            # parsed\n            date = parse_date_string(date)\n        except ValueError:\n            # Then it means it is a custom string like \"Fall 2023\"\n            date = date\n\n    return date\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Event.check_dates","title":"<code>check_dates(model)</code>  <code>classmethod</code>","text":"<p>Make sure that either <code>start_date</code> and <code>end_date</code> or only <code>date</code> is provided.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@model_validator(mode=\"after\")\n@classmethod\ndef check_dates(cls, model):\n    \"\"\"Make sure that either `#!python start_date` and `#!python end_date` or only\n    `#!python date` is provided.\n    \"\"\"\n    date_is_provided = False\n    start_date_is_provided = False\n    end_date_is_provided = False\n    if model.date is not None:\n        date_is_provided = True\n    if model.start_date is not None:\n        start_date_is_provided = True\n    if model.end_date is not None:\n        end_date_is_provided = True\n\n    if date_is_provided and start_date_is_provided and end_date_is_provided:\n        logger.warning(\n            '\"start_date\", \"end_date\" and \"date\" are all provided in of the'\n            \" entries. Therefore, date will be ignored.\"\n        )\n        model.date = None\n\n    elif date_is_provided and start_date_is_provided and not end_date_is_provided:\n        logger.warning(\n            'Both \"date\" and \"start_date\" is provided in of the entries.'\n            ' \"start_date\" will be ignored.'\n        )\n        model.start_date = None\n        model.end_date = None\n\n    elif date_is_provided and end_date_is_provided and not start_date_is_provided:\n        logger.warning(\n            'Both \"date\" and \"end_date\" is provided in of the entries. \"end_date\"'\n            \" will be ignored.\"\n        )\n        model.start_date = None\n        model.end_date = None\n\n    elif start_date_is_provided and not end_date_is_provided:\n        logger.warning(\n            '\"start_date\" is provided in of the entries, but \"end_date\" is not.'\n            ' \"end_date\" will be set to \"present\".'\n        )\n        model.end_date = \"present\"\n\n    if model.start_date is not None and model.end_date is not None:\n        if model.end_date == \"present\":\n            end_date = Date.today()\n        elif isinstance(model.end_date, int):\n            # Then it means user only provided the year, so convert it to a Date\n            # object with the first day of the year (just for the date comparison)\n            end_date = Date(model.end_date, 1, 1)\n        elif isinstance(model.end_date, Date):\n            # Then it means user provided either YYYY-MM-DD or YYYY-MM\n            end_date = model.end_date\n        else:\n            raise RuntimeError(\"end_date is neither an integer nor a Date object.\")\n\n        if isinstance(model.start_date, int):\n            # Then it means user only provided the year, so convert it to a Date\n            # object with the first day of the year (just for the date comparison)\n            start_date = Date(model.start_date, 1, 1)\n        elif isinstance(model.start_date, Date):\n            # Then it means user provided either YYYY-MM-DD or YYYY-MM\n            start_date = model.start_date\n        else:\n            raise RuntimeError(\n                \"start_date is neither an integer nor a Date object.\"\n            )\n\n        if start_date &gt; end_date:\n            raise ValueError(\n                '\"start_date\" can not be after \"end_date\". Please check the dates.'\n            )\n\n    return model\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.OneLineEntry","title":"<code>OneLineEntry</code>","text":"<p>             Bases: <code>Event</code></p> <p>This class stores OneLineEntry information.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class OneLineEntry(Event):\n    \"\"\"This class stores [OneLineEntry](../user_guide.md#onelineentry) information.\"\"\"\n\n    name: LaTeXString = Field(\n        title=\"Name\",\n        description=\"The name of the entry. It will be shown as bold text.\",\n    )\n    details: LaTeXString = Field(\n        title=\"Details\",\n        description=\"The details of the entry. It will be shown as normal text.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.NormalEntry","title":"<code>NormalEntry</code>","text":"<p>             Bases: <code>Event</code></p> <p>This class stores NormalEntry information.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class NormalEntry(Event):\n    \"\"\"This class stores [NormalEntry](../user_guide.md#normalentry) information.\"\"\"\n\n    name: LaTeXString = Field(\n        title=\"Name\",\n        description=\"The name of the entry. It will be shown as bold text.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.ExperienceEntry","title":"<code>ExperienceEntry</code>","text":"<p>             Bases: <code>Event</code></p> <p>This class stores ExperienceEntry information.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class ExperienceEntry(Event):\n    \"\"\"This class stores [ExperienceEntry](../user_guide.md#experienceentry) information.\"\"\"\n\n    company: LaTeXString = Field(\n        title=\"Company\",\n        description=\"The company name. It will be shown as bold text.\",\n    )\n    position: LaTeXString = Field(\n        title=\"Position\",\n        description=\"The position. It will be shown as normal text.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.EducationEntry","title":"<code>EducationEntry</code>","text":"<p>             Bases: <code>Event</code></p> <p>This class stores EducationEntry information.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class EducationEntry(Event):\n    \"\"\"This class stores [EducationEntry](../user_guide.md#educationentry) information.\"\"\"\n\n    institution: LaTeXString = Field(\n        title=\"Institution\",\n        description=\"The institution name. It will be shown as bold text.\",\n        examples=[\"Bogazici University\"],\n    )\n    area: LaTeXString = Field(\n        title=\"Area\",\n        description=\"The area of study. It will be shown as normal text.\",\n    )\n    study_type: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Study Type\",\n        description=\"The type of the degree.\",\n        examples=[\"BS\", \"BA\", \"PhD\", \"MS\"],\n    )\n    gpa: Optional[LaTeXString | float] = Field(\n        default=None,\n        title=\"GPA\",\n        description=\"The GPA of the degree.\",\n    )\n    transcript_url: Optional[HttpUrl] = Field(\n        default=None,\n        title=\"Transcript URL\",\n        description=(\n            \"The URL of the transcript. It will be shown as a link next to the GPA.\"\n        ),\n        examples=[\"https://example.com/transcript.pdf\"],\n    )\n\n    @computed_field\n    @cached_property\n    def highlight_strings(self) -&gt; list[LaTeXString]:\n        highlight_strings = []\n\n        if self.gpa is not None:\n            gpaString = f\"GPA: {self.gpa}\"\n            if self.transcript_url is not None:\n                gpaString += f\" ([Transcript]({self.transcript_url}))\"\n            highlight_strings.append(gpaString)\n\n        if self.highlights is not None:\n            highlight_strings.extend(self.highlights)\n\n        return highlight_strings\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.PublicationEntry","title":"<code>PublicationEntry</code>","text":"<p>             Bases: <code>Event</code></p> <p>This class stores PublicationEntry information.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class PublicationEntry(Event):\n    \"\"\"This class stores [PublicationEntry](../user_guide.md#publicationentry) information.\"\"\"\n\n    title: LaTeXString = Field(\n        title=\"Title of the Publication\",\n        description=\"The title of the publication. It will be shown as bold text.\",\n    )\n    authors: list[LaTeXString] = Field(\n        title=\"Authors\",\n        description=\"The authors of the publication in order as a list of strings.\",\n    )\n    doi: str = Field(\n        title=\"DOI\",\n        description=\"The DOI of the publication.\",\n        examples=[\"10.48550/arXiv.2310.03138\"],\n    )\n    date: LaTeXString = Field(\n        title=\"Publication Date\",\n        description=\"The date of the publication.\",\n        examples=[\"2021-10-31\"],\n    )\n    cited_by: Optional[int] = Field(\n        default=None,\n        title=\"Cited By\",\n        description=\"The number of citations of the publication.\",\n    )\n    journal: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Journal\",\n        description=\"The journal or the conference name.\",\n    )\n\n    @field_validator(\"doi\")\n    @classmethod\n    def check_doi(cls, doi: str) -&gt; str:\n        \"\"\"Check if the DOI exists in the DOI System.\"\"\"\n        doi_url = f\"https://doi.org/{doi}\"\n\n        try:\n            urllib.request.urlopen(doi_url)\n        except urllib.request.HTTPError as err:\n            if err.code == 404:\n                raise ValueError(f\"{doi} cannot be found in the DOI System.\")\n\n        return doi\n\n    @computed_field\n    @cached_property\n    def doi_url(self) -&gt; str:\n        return f\"https://doi.org/{self.doi}\"\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.PublicationEntry.check_doi","title":"<code>check_doi(doi)</code>  <code>classmethod</code>","text":"<p>Check if the DOI exists in the DOI System.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@field_validator(\"doi\")\n@classmethod\ndef check_doi(cls, doi: str) -&gt; str:\n    \"\"\"Check if the DOI exists in the DOI System.\"\"\"\n    doi_url = f\"https://doi.org/{doi}\"\n\n    try:\n        urllib.request.urlopen(doi_url)\n    except urllib.request.HTTPError as err:\n        if err.code == 404:\n            raise ValueError(f\"{doi} cannot be found in the DOI System.\")\n\n    return doi\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SocialNetwork","title":"<code>SocialNetwork</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores a social network information.</p> <p>Currently, only LinkedIn, Github, Mastodon, and Instagram are supported.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SocialNetwork(BaseModel):\n    \"\"\"This class stores a social network information.\n\n    Currently, only LinkedIn, Github, Mastodon, and Instagram are supported.\n    \"\"\"\n\n    network: Literal[\"LinkedIn\", \"GitHub\", \"Instagram\", \"Orcid\", \"Mastodon\"] = Field(\n        title=\"Social Network\",\n        description=\"The social network name.\",\n    )\n    username: str = Field(\n        title=\"Username\",\n        description=\"The username of the social network. The link will be generated.\",\n    )\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Connection","title":"<code>Connection</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores a connection/communication information.</p> Warning <p>This class isn't designed for users to use, but it is used by RenderCV to make the $\\LaTeX$ templating easier.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class Connection(BaseModel):\n    \"\"\"This class stores a connection/communication information.\n\n    Warning:\n        This class isn't designed for users to use, but it is used by RenderCV to make\n        the $\\\\LaTeX$ templating easier.\n    \"\"\"\n\n    name: Literal[\n        \"LinkedIn\",\n        \"GitHub\",\n        \"Instagram\",\n        \"Orcid\",\n        \"Mastodon\",\n        \"phone\",\n        \"email\",\n        \"website\",\n        \"location\",\n    ]\n    value: str\n\n    @staticmethod\n    def is_valid_hostname(hostname: str) -&gt; bool:\n        \"\"\"Is hostname a valid hostname by RFCs 952 and 1123\"\"\"\n\n        # slightly modified from\n        # https://stackoverflow.com/a/33214423/1304076\n        if hostname[-1] == \".\":\n            # strip exactly one dot from the right, if present\n            hostname = hostname[:-1]\n        if len(hostname) &gt; 253:\n            return False\n\n        labels = hostname.split(\".\")\n\n        # the last label must be not all-numeric\n        if re.match(r\"[0-9]+$\", labels[-1]):\n            return False\n\n        # labels cannot begin with a hyphen\n        # labels must have at least character\n        # labels may not have more than 63 characters\n        allowed = re.compile(r\"(?!-)[a-z0-9-]{1,63}(?&lt;!-)$\", re.IGNORECASE)\n        return all(allowed.match(label) for label in labels)\n\n    @staticmethod\n    def MastodonUname2Url(address: str) -&gt; Optional[HttpUrl]:\n        \"\"\"returns profile url from a mastodon user address.\n\n        Args:\n            address (str): A Mastodon user address. E.g., \"user@social.example\"\n\n        Returns:\n            A pydantic HttpUrl object with the https URL for the user profile\n\n        Example:\n            ```\n            url = MastodonUname2Url(\"user@social.example\")\n            assert(url == HttpUrl(http://social.example/@user))\n            ```\n\n        Exceptions:\n            ValueError if the address is malformed.\n            Note that well-formed addresses should never yield\n            syntactically invalid URLs.\n        \"\"\"\n\n        # The closest thing to a formal spec of Mastodon usernames\n        # where these regular expressions from a (reference?)\n        # implementation\n        #\n        # https://github.com/mastodon/mastodon/blob/f1657e6d6275384c199956e8872115fdcec600b0/app/models/account.rb#L68\n        #\n        # USERNAME_RE   = /[a-z0-9_]+([a-z0-9_.-]+[a-z0-9_]+)?/i\n        # MENTION_RE    = %r{(?&lt;![=/[:word:]])@((#{USERNAME_RE})(?:@[[:word:].-]+[[:word:]]+)?)}i\n        #\n        # `[[:word:]]` in Ruby includes lots of things that could never be in a # domain name. As my intent here is to construct an HTTPS URL,\n        # What we need are valid hostnames,\n        # and so need to satisfy the constraints of RFC 952 and and 1123.\n\n        pattern = re.compile(\n            r\"\"\"\n            ^\\s*                    # ignore leading spaces\n            @?                      # Optional @ prefix\n            (?P&lt;uname&gt;[a-z0-9_]+([a-z0-9_.-]+[a-z0-9_]+)?)  # username part\n            @                       # separator\n            (?P&lt;domain&gt;[a-z0-9]+([a-z0-9.-]+)?) # domain part\n            \\s*$                    # ignore trailing whitespace\n        \"\"\",\n            re.VERBOSE | re.IGNORECASE,\n        )\n\n        m = pattern.match(address)\n        if m is None:\n            raise ValueError(\"Invalid mastodon address\")\n        uname = m.group(\"uname\")\n        domain = m.group(\"domain\")\n\n        # the domain part of pattern allows some things that are not\n        # valid names. So we run a stricter check\n        if not Connection.is_valid_hostname(domain):\n            raise ValueError(\"Invalid hostname in mastodon address\")\n\n        url = HttpUrl(f\"https://{domain}/@{uname}\")\n        return url\n\n    @computed_field\n    @cached_property\n    def url(self) -&gt; Optional[HttpUrl | str]:\n        if self.name == \"LinkedIn\":\n            url = f\"https://www.linkedin.com/in/{self.value}\"\n        elif self.name == \"GitHub\":\n            url = f\"https://www.github.com/{self.value}\"\n        elif self.name == \"Instagram\":\n            url = f\"https://www.instagram.com/{self.value}\"\n        elif self.name == \"Orcid\":\n            url = f\"https://orcid.org/{self.value}\"\n        elif self.name == \"Mastodon\":\n            url = self.MastodonUname2Url(self.value)\n        elif self.name == \"email\":\n            url = f\"mailto:{self.value}\"\n        elif self.name == \"website\":\n            url = self.value\n        elif self.name == \"phone\":\n            url = self.value\n        elif self.name == \"location\":\n            url = None\n        else:\n            raise RuntimeError(f'\"{self.name}\" is not a valid connection.')\n\n        return url\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Connection.is_valid_hostname","title":"<code>is_valid_hostname(hostname)</code>  <code>staticmethod</code>","text":"<p>Is hostname a valid hostname by RFCs 952 and 1123</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@staticmethod\ndef is_valid_hostname(hostname: str) -&gt; bool:\n    \"\"\"Is hostname a valid hostname by RFCs 952 and 1123\"\"\"\n\n    # slightly modified from\n    # https://stackoverflow.com/a/33214423/1304076\n    if hostname[-1] == \".\":\n        # strip exactly one dot from the right, if present\n        hostname = hostname[:-1]\n    if len(hostname) &gt; 253:\n        return False\n\n    labels = hostname.split(\".\")\n\n    # the last label must be not all-numeric\n    if re.match(r\"[0-9]+$\", labels[-1]):\n        return False\n\n    # labels cannot begin with a hyphen\n    # labels must have at least character\n    # labels may not have more than 63 characters\n    allowed = re.compile(r\"(?!-)[a-z0-9-]{1,63}(?&lt;!-)$\", re.IGNORECASE)\n    return all(allowed.match(label) for label in labels)\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.Connection.MastodonUname2Url","title":"<code>MastodonUname2Url(address)</code>  <code>staticmethod</code>","text":"<p>returns profile url from a mastodon user address.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>A Mastodon user address. E.g., \"user@social.example\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[HttpUrl]</code>         \u2013          <p>A pydantic HttpUrl object with the https URL for the user profile</p> </li> </ul> Example <pre><code>url = MastodonUname2Url(\"user@social.example\")\nassert(url == HttpUrl(http://social.example/@user))\n</code></pre> Source code in <code>rendercv/data_model.py</code> <pre><code>@staticmethod\ndef MastodonUname2Url(address: str) -&gt; Optional[HttpUrl]:\n    \"\"\"returns profile url from a mastodon user address.\n\n    Args:\n        address (str): A Mastodon user address. E.g., \"user@social.example\"\n\n    Returns:\n        A pydantic HttpUrl object with the https URL for the user profile\n\n    Example:\n        ```\n        url = MastodonUname2Url(\"user@social.example\")\n        assert(url == HttpUrl(http://social.example/@user))\n        ```\n\n    Exceptions:\n        ValueError if the address is malformed.\n        Note that well-formed addresses should never yield\n        syntactically invalid URLs.\n    \"\"\"\n\n    # The closest thing to a formal spec of Mastodon usernames\n    # where these regular expressions from a (reference?)\n    # implementation\n    #\n    # https://github.com/mastodon/mastodon/blob/f1657e6d6275384c199956e8872115fdcec600b0/app/models/account.rb#L68\n    #\n    # USERNAME_RE   = /[a-z0-9_]+([a-z0-9_.-]+[a-z0-9_]+)?/i\n    # MENTION_RE    = %r{(?&lt;![=/[:word:]])@((#{USERNAME_RE})(?:@[[:word:].-]+[[:word:]]+)?)}i\n    #\n    # `[[:word:]]` in Ruby includes lots of things that could never be in a # domain name. As my intent here is to construct an HTTPS URL,\n    # What we need are valid hostnames,\n    # and so need to satisfy the constraints of RFC 952 and and 1123.\n\n    pattern = re.compile(\n        r\"\"\"\n        ^\\s*                    # ignore leading spaces\n        @?                      # Optional @ prefix\n        (?P&lt;uname&gt;[a-z0-9_]+([a-z0-9_.-]+[a-z0-9_]+)?)  # username part\n        @                       # separator\n        (?P&lt;domain&gt;[a-z0-9]+([a-z0-9.-]+)?) # domain part\n        \\s*$                    # ignore trailing whitespace\n    \"\"\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    m = pattern.match(address)\n    if m is None:\n        raise ValueError(\"Invalid mastodon address\")\n    uname = m.group(\"uname\")\n    domain = m.group(\"domain\")\n\n    # the domain part of pattern allows some things that are not\n    # valid names. So we run a stricter check\n    if not Connection.is_valid_hostname(domain):\n        raise ValueError(\"Invalid hostname in mastodon address\")\n\n    url = HttpUrl(f\"https://{domain}/@{uname}\")\n    return url\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionBase","title":"<code>SectionBase</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class stores a section information.</p> <p>It is the parent class of all the section classes like <code>SectionWithEducationEntries</code>, <code>SectionWithExperienceEntries</code>, <code>SectionWithNormalEntries</code>, <code>SectionWithOneLineEntries</code>, and <code>SectionWithPublicationEntries</code>.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionBase(BaseModel):\n    \"\"\"This class stores a section information.\n\n    It is the parent class of all the section classes like\n    `#!python SectionWithEducationEntries`, `#!python SectionWithExperienceEntries`,\n    `#!python SectionWithNormalEntries`, `#!python SectionWithOneLineEntries`, and\n    `#!python SectionWithPublicationEntries`.\n    \"\"\"\n\n    title: LaTeXString = Field(\n        title=\"Section Title\",\n        description=\"The title of the section.\",\n        examples=[\"My Custom Section\"],\n    )\n    link_text: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Link Text\",\n        description=(\n            \"If the section has a link, then what should be the text of the link? If\"\n            \" this field is not provided, then the link text will be generated\"\n            \" automatically based on the URL.\"\n        ),\n        examples=[\"view on GitHub\", \"view on LinkedIn\"],\n    )\n\n    @field_validator(\"title\")\n    @classmethod\n    def make_first_letters_uppercase(cls, title: LaTeXString) -&gt; LaTeXString:\n        \"\"\"Capitalize the first letters of the words in the title.\"\"\"\n        return title.title()\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionBase.make_first_letters_uppercase","title":"<code>make_first_letters_uppercase(title)</code>  <code>classmethod</code>","text":"<p>Capitalize the first letters of the words in the title.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@field_validator(\"title\")\n@classmethod\ndef make_first_letters_uppercase(cls, title: LaTeXString) -&gt; LaTeXString:\n    \"\"\"Capitalize the first letters of the words in the title.\"\"\"\n    return title.title()\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionWithEducationEntries","title":"<code>SectionWithEducationEntries</code>","text":"<p>             Bases: <code>SectionBase</code></p> <p>This class stores a section with EducationEntrys.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionWithEducationEntries(SectionBase):\n    \"\"\"This class stores a section with\n    [EducationEntry](../user_guide.md#educationentry)s.\n    \"\"\"\n\n    entry_type: Literal[\"EducationEntry\"] = entry_type_field\n    entries: list[EducationEntry] = entries_field\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionWithExperienceEntries","title":"<code>SectionWithExperienceEntries</code>","text":"<p>             Bases: <code>SectionBase</code></p> <p>This class stores a section with ExperienceEntrys.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionWithExperienceEntries(SectionBase):\n    \"\"\"This class stores a section with\n    [ExperienceEntry](../user_guide.md#experienceentry)s.\n    \"\"\"\n\n    entry_type: Literal[\"ExperienceEntry\"] = entry_type_field\n    entries: list[ExperienceEntry] = entries_field\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionWithNormalEntries","title":"<code>SectionWithNormalEntries</code>","text":"<p>             Bases: <code>SectionBase</code></p> <p>This class stores a section with NormalEntrys.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionWithNormalEntries(SectionBase):\n    \"\"\"This class stores a section with\n    [NormalEntry](../user_guide.md#normalentry)s.\n    \"\"\"\n\n    entry_type: Literal[\"NormalEntry\"] = entry_type_field\n    entries: list[NormalEntry] = entries_field\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionWithOneLineEntries","title":"<code>SectionWithOneLineEntries</code>","text":"<p>             Bases: <code>SectionBase</code></p> <p>This class stores a section with OneLineEntrys.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionWithOneLineEntries(SectionBase):\n    \"\"\"This class stores a section with\n    [OneLineEntry](../user_guide.md#onelineentry)s.\n    \"\"\"\n\n    entry_type: Literal[\"OneLineEntry\"] = entry_type_field\n    entries: list[OneLineEntry] = entries_field\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.SectionWithPublicationEntries","title":"<code>SectionWithPublicationEntries</code>","text":"<p>             Bases: <code>SectionBase</code></p> <p>This class stores a section with PublicationEntrys.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class SectionWithPublicationEntries(SectionBase):\n    \"\"\"This class stores a section with\n    [PublicationEntry](../user_guide.md#publicationentry)s.\n    \"\"\"\n\n    entry_type: Literal[\"PublicationEntry\"] = entry_type_field\n    entries: list[PublicationEntry] = entries_field\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.CurriculumVitae","title":"<code>CurriculumVitae</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class bindes all the information of a CV together.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class CurriculumVitae(BaseModel):\n    \"\"\"This class bindes all the information of a CV together.\"\"\"\n\n    name: LaTeXString = Field(\n        title=\"Name\",\n        description=\"The name of the person.\",\n    )\n    label: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Label\",\n        description=\"The label of the person.\",\n    )\n    location: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Location\",\n        description=\"The location of the person. This is not rendered currently.\",\n    )\n    email: Optional[EmailStr] = Field(\n        default=None,\n        title=\"Email\",\n        description=\"The email of the person. It will be rendered in the heading.\",\n    )\n    phone: Optional[PhoneNumber] = None\n    website: Optional[HttpUrl] = None\n    social_networks: Optional[list[SocialNetwork]] = Field(\n        default=None,\n        title=\"Social Networks\",\n        description=(\n            \"The social networks of the person. They will be rendered in the heading.\"\n        ),\n    )\n    summary: Optional[LaTeXString] = Field(\n        default=None,\n        title=\"Summary\",\n        description=\"The summary of the person.\",\n    )\n    cover_letter: Optional[CoverLetter] = Field(\n        default=None,\n        title=\"Cover Letter\",\n        description=\"The cover letter.\",\n    )\n    # Sections:\n    section_order: Optional[list[str]] = Field(\n        default=None,\n        title=\"Section Order\",\n        description=(\n            \"The order of sections in the CV. The section title should be used.\"\n        ),\n    )\n    education: Optional[list[EducationEntry]] = Field(\n        default=None,\n        title=\"Education\",\n        description=\"The education entries of the person.\",\n    )\n    experience: Optional[list[ExperienceEntry]] = Field(\n        default=None,\n        title=\"Experience\",\n        description=\"The experience entries of the person.\",\n    )\n    work_experience: Optional[list[ExperienceEntry]] = Field(\n        default=None,\n        title=\"Work Experience\",\n        description=\"The work experience entries of the person.\",\n    )\n    projects: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"Projects\",\n        description=\"The project entries of the person.\",\n    )\n    academic_projects: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"Academic Projects\",\n        description=\"The academic project entries of the person.\",\n    )\n    university_projects: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"University Projects\",\n        description=\"The university project entries of the person.\",\n    )\n    personal_projects: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"Personal Projects\",\n        description=\"The personal project entries of the person.\",\n    )\n    publications: Optional[list[PublicationEntry]] = Field(\n        default=None,\n        title=\"Publications\",\n        description=\"The publication entries of the person.\",\n    )\n    certificates: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"Certificates\",\n        description=\"The certificate entries of the person.\",\n    )\n    extracurricular_activities: Optional[list[ExperienceEntry]] = Field(\n        default=None,\n        title=\"Extracurricular Activities\",\n        description=\"The extracurricular activity entries of the person.\",\n    )\n    test_scores: Optional[list[OneLineEntry]] = Field(\n        default=None,\n        title=\"Test Scores\",\n        description=\"The test score entries of the person.\",\n    )\n    programming_skills: Optional[list[NormalEntry]] = Field(\n        default=None,\n        title=\"Programming Skills\",\n        description=\"The programming skill entries of the person.\",\n    )\n    skills: Optional[list[OneLineEntry]] = Field(\n        default=None,\n        title=\"Skills\",\n        description=\"The skill entries of the person.\",\n    )\n    other_skills: Optional[list[OneLineEntry]] = Field(\n        default=None,\n        title=\"Skills\",\n        description=\"The skill entries of the person.\",\n    )\n    awards: Optional[list[OneLineEntry]] = Field(\n        default=None,\n        title=\"Awards\",\n        description=\"The award entries of the person.\",\n    )\n    interests: Optional[list[OneLineEntry]] = Field(\n        default=None,\n        title=\"Interests\",\n        description=\"The interest entries of the person.\",\n    )\n    custom_sections: Optional[list[Section]] = Field(\n        default=None,\n        title=\"Custom Sections\",\n        description=(\n            \"Custom sections with custom section titles can be rendered as well.\"\n        ),\n    )\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def check_if_the_section_names_are_unique(cls, model):\n        \"\"\"Check if the section names are unique.\"\"\"\n        pre_defined_section_names = [\n            \"Education\",\n            \"Work Experience\",\n            \"Academic Projects\",\n            \"Personal Projects\",\n            \"Certificates\",\n            \"Extracurricular Activities\",\n            \"Test Scores\",\n            \"Skills\",\n            \"Publications\",\n        ]\n        if model.custom_sections is not None:\n            custom_section_names = []\n            for custom_section in model.custom_sections:\n                custom_section_names.append(custom_section.title)\n\n            section_names = pre_defined_section_names + custom_section_names\n        else:\n            section_names = pre_defined_section_names\n\n        seen = set()\n        duplicates = {val for val in section_names if (val in seen or seen.add(val))}\n        if len(duplicates) &gt; 0:\n            raise ValueError(\n                \"The section names should be unique. The following section names are\"\n                f\" duplicated: {duplicates}\"\n            )\n\n        return model\n\n    @computed_field\n    @cached_property\n    def connections(self) -&gt; list[Connection]:\n        connections = []\n        if self.location is not None:\n            connections.append(Connection(name=\"location\", value=self.location))\n        if self.phone is not None:\n            connections.append(Connection(name=\"phone\", value=self.phone))\n        if self.email is not None:\n            connections.append(Connection(name=\"email\", value=self.email))\n        if self.website is not None:\n            connections.append(Connection(name=\"website\", value=str(self.website)))\n        if self.social_networks is not None:\n            for social_network in self.social_networks:\n                connections.append(\n                    Connection(\n                        name=social_network.network, value=social_network.username\n                    )\n                )\n\n        return connections\n\n    @computed_field\n    @cached_property\n    def sections(self) -&gt; list[SectionBase]:\n        sections = []\n\n        # Pre-defined sections (i.e. sections that are not custom)):\n        pre_defined_sections = {\n            \"Education\": self.education,\n            \"Experience\": self.experience,\n            \"Work Experience\": self.work_experience,\n            \"Publications\": self.publications,\n            \"Projects\": self.projects,\n            \"Academic Projects\": self.academic_projects,\n            \"University Projects\": self.university_projects,\n            \"Personal Projects\": self.personal_projects,\n            \"Certificates\": self.certificates,\n            \"Extracurricular Activities\": self.extracurricular_activities,\n            \"Test Scores\": self.test_scores,\n            \"Skills\": self.skills,\n            \"Programming Skills\": self.programming_skills,\n            \"Other Skills\": self.other_skills,\n            \"Awards\": self.awards,\n            \"Interests\": self.interests,\n            \"Programming Skills\": self.programming_skills,\n        }\n\n        section_order_is_given = True\n        if self.section_order is None:\n            section_order_is_given = False\n            # If the user didn't specify the section order, then use the default order:\n            self.section_order = list(pre_defined_sections.keys())\n            if self.custom_sections is not None:\n                # If the user specified custom sections, then add them to the end of the\n                # section order with the same order as they are in the input file:\n                self.section_order.extend(\n                    [section.title for section in self.custom_sections]\n                )\n\n        link_text = None\n        entry_type = None\n        entries = None\n        for section_name in self.section_order:\n            # Create a section for each section name in the section order:\n            if section_name in pre_defined_sections:\n                if pre_defined_sections[section_name] is None:\n                    if section_order_is_given:\n                        raise ValueError(\n                            f'The section \"{section_name}\" is not found in the CV.'\n                            \" Please create the section or delete it from the section\"\n                            \" order.\"\n                        )\n                    else:\n                        continue\n\n                entry_type = pre_defined_sections[section_name][0].__class__.__name__\n                entries = pre_defined_sections[section_name]\n                if section_name == \"Test Scores\":\n                    link_text = \"Score Report\"\n                elif section_name == \"Certificates\":\n                    link_text = \"Certificate\"\n                else:\n                    link_text = None\n            else:\n                # If the section is not pre-defined, then it is a custom section.\n                # Find the corresponding custom section and get its entries:\n                for custom_section in self.custom_sections:  # type: ignore\n                    if custom_section.title == section_name:\n                        entry_type = custom_section.entries[0].__class__.__name__\n                        link_text = custom_section.link_text\n                        entries = custom_section.entries\n                        break\n                    else:\n                        entry_type = None\n                        link_text = None\n                        entries = None\n\n                if entry_type is None or entries is None:\n                    raise ValueError(\n                        f'\"{section_name}\" is not a valid section name. Please create a'\n                        \" custom section with this name or delete it from the section\"\n                        \" order.\"\n                    )\n\n            object_map = {\n                \"EducationEntry\": SectionWithEducationEntries,\n                \"ExperienceEntry\": SectionWithExperienceEntries,\n                \"NormalEntry\": SectionWithNormalEntries,\n                \"OneLineEntry\": SectionWithOneLineEntries,\n                \"PublicationEntry\": SectionWithPublicationEntries,\n            }\n\n            section = object_map[entry_type](\n                title=section_name,\n                entry_type=entry_type,  # type: ignore\n                entries=entries,\n                link_text=link_text,\n            )\n            sections.append(section)\n\n        # Check if any of the pre-defined sections are missing from the section order:\n        for section_name in pre_defined_sections:\n            if pre_defined_sections[section_name] is not None:\n                if section_name not in self.section_order:\n                    logger.warning(\n                        f'The section \"{section_name}\" is not found in the section'\n                        \" order! It will not be rendered.\"\n                    )\n\n        # Check if any of the custom sections are missing from the section order:\n        if self.custom_sections is not None:\n            for custom_section in self.custom_sections:\n                if custom_section.title not in self.section_order:\n                    logger.warning(\n                        f'The custom section \"{custom_section.title}\" is not found in'\n                        \" the section order! It will not be rendered.\"\n                    )\n\n        return sections\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.CurriculumVitae.check_if_the_section_names_are_unique","title":"<code>check_if_the_section_names_are_unique(model)</code>  <code>classmethod</code>","text":"<p>Check if the section names are unique.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@model_validator(mode=\"after\")\n@classmethod\ndef check_if_the_section_names_are_unique(cls, model):\n    \"\"\"Check if the section names are unique.\"\"\"\n    pre_defined_section_names = [\n        \"Education\",\n        \"Work Experience\",\n        \"Academic Projects\",\n        \"Personal Projects\",\n        \"Certificates\",\n        \"Extracurricular Activities\",\n        \"Test Scores\",\n        \"Skills\",\n        \"Publications\",\n    ]\n    if model.custom_sections is not None:\n        custom_section_names = []\n        for custom_section in model.custom_sections:\n            custom_section_names.append(custom_section.title)\n\n        section_names = pre_defined_section_names + custom_section_names\n    else:\n        section_names = pre_defined_section_names\n\n    seen = set()\n    duplicates = {val for val in section_names if (val in seen or seen.add(val))}\n    if len(duplicates) &gt; 0:\n        raise ValueError(\n            \"The section names should be unique. The following section names are\"\n            f\" duplicated: {duplicates}\"\n        )\n\n    return model\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.RenderCVDataModel","title":"<code>RenderCVDataModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>This class binds both the CV and the design information together.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>class RenderCVDataModel(BaseModel):\n    \"\"\"This class binds both the CV and the design information together.\"\"\"\n\n    design: Design = Field(\n        default=Design(),\n        title=\"Design\",\n        description=\"The design of the CV.\",\n    )\n    cv: CurriculumVitae = Field(\n        default=CurriculumVitae(name=\"John Doe\"),\n        title=\"Curriculum Vitae\",\n        description=\"The data of the CV.\",\n    )\n\n    @model_validator(mode=\"after\")\n    @classmethod\n    def check_classical_theme_show_timespan_in(cls, model):\n        \"\"\"Check if the sections that are specified in the \"show_timespan_in\" option\n        exist in the CV.\n        \"\"\"\n        if model.design.theme == \"classic\":\n            design: Design = model.design\n            cv: CurriculumVitae = model.cv\n            section_titles = [section.title for section in cv.sections]\n            for title in design.options.show_timespan_in:  # type: ignore\n                if title not in section_titles:\n                    not_used_section_titles = list(\n                        set(section_titles) - set(design.options.show_timespan_in)\n                    )\n                    not_used_section_titles = \", \".join(not_used_section_titles)\n                    raise ValueError(\n                        f'The section \"{title}\" that is specified in the'\n                        ' \"show_timespan_in\" option is not found in the CV. You'\n                        \" might have wanted to use one of these:\"\n                        f\" {not_used_section_titles}.\"\n                    )\n\n        return model\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.RenderCVDataModel.check_classical_theme_show_timespan_in","title":"<code>check_classical_theme_show_timespan_in(model)</code>  <code>classmethod</code>","text":"<p>Check if the sections that are specified in the \"show_timespan_in\" option exist in the CV.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>@model_validator(mode=\"after\")\n@classmethod\ndef check_classical_theme_show_timespan_in(cls, model):\n    \"\"\"Check if the sections that are specified in the \"show_timespan_in\" option\n    exist in the CV.\n    \"\"\"\n    if model.design.theme == \"classic\":\n        design: Design = model.design\n        cv: CurriculumVitae = model.cv\n        section_titles = [section.title for section in cv.sections]\n        for title in design.options.show_timespan_in:  # type: ignore\n            if title not in section_titles:\n                not_used_section_titles = list(\n                    set(section_titles) - set(design.options.show_timespan_in)\n                )\n                not_used_section_titles = \", \".join(not_used_section_titles)\n                raise ValueError(\n                    f'The section \"{title}\" that is specified in the'\n                    ' \"show_timespan_in\" option is not found in the CV. You'\n                    \" might have wanted to use one of these:\"\n                    f\" {not_used_section_titles}.\"\n                )\n\n    return model\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.escape_latex_characters","title":"<code>escape_latex_characters(sentence)</code>","text":"<p>Escape LaTeX characters in a sentence.</p> Example <p><pre><code>escape_latex_characters(\"This is a # sentence.\")\n</code></pre> will return: <code>\"This is a \\# sentence.\"</code></p> Source code in <code>rendercv/data_model.py</code> <pre><code>def escape_latex_characters(sentence: str) -&gt; str:\n    \"\"\"Escape LaTeX characters in a sentence.\n\n    Example:\n        ```python\n        escape_latex_characters(\"This is a # sentence.\")\n        ```\n        will return:\n        `#!python \"This is a \\\\# sentence.\"`\n    \"\"\"\n\n    # Dictionary of escape characters:\n    escape_characters = {\n        \"#\": r\"\\#\",\n        # \"$\": r\"\\$\", # Don't escape $ as it is used for math mode\n        \"%\": r\"\\%\",\n        \"&amp;\": r\"\\&amp;\",\n        \"~\": r\"\\textasciitilde{}\",\n        # \"_\": r\"\\_\", # Don't escape _ as it is used for math mode\n        # \"^\": r\"\\textasciicircum{}\", # Don't escape ^ as it is used for math mode\n    }\n\n    # Don't escape links as hyperref will do it automatically:\n\n    # Find all the links in the sentence:\n    links = re.findall(r\"\\[.*?\\]\\(.*?\\)\", sentence)\n\n    # Replace the links with a placeholder:\n    for link in links:\n        sentence = sentence.replace(link, \"!!-link-!!\")\n\n    # Handle backslash and curly braces separately because the other characters are\n    # escaped with backslash and curly braces:\n    # --don't escape curly braces as they are used heavily in LaTeX--:\n    # sentence = sentence.replace(\"{\", \"&gt;&gt;{\")\n    # sentence = sentence.replace(\"}\", \"&gt;&gt;}\")\n    # --don't escape backslash as it is used heavily in LaTeX--:\n    # sentence = sentence.replace(\"\\\\\", \"\\\\textbackslash{}\")\n    # sentence = sentence.replace(\"&gt;&gt;{\", \"\\\\{\")\n    # sentence = sentence.replace(\"&gt;&gt;}\", \"\\\\}\")\n\n    # Loop through the letters of the sentence and if you find an escape character,\n    # replace it with its LaTeX equivalent:\n    copy_of_the_sentence = sentence\n    for character in copy_of_the_sentence:\n        if character in escape_characters:\n            sentence = sentence.replace(character, escape_characters[character])\n\n    # Replace the links with the original links:\n    for link in links:\n        sentence = sentence.replace(\"!!-link-!!\", link)\n\n    return sentence\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.parse_date_string","title":"<code>parse_date_string(date_string)</code>","text":"<p>Parse a date string in YYYY-MM-DD, YYYY-MM, or YYYY format and return a datetime.date object.</p> <p>Parameters:</p> <ul> <li> <code>date_string</code>             (<code>str</code>)         \u2013          <p>The date string to parse.</p> </li> </ul> <p>Returns:     datetime.date: The parsed date.</p> Source code in <code>rendercv/data_model.py</code> <pre><code>def parse_date_string(date_string: str) -&gt; Date | int:\n    \"\"\"Parse a date string in YYYY-MM-DD, YYYY-MM, or YYYY format and return a\n    datetime.date object.\n\n    Args:\n        date_string (str): The date string to parse.\n    Returns:\n        datetime.date: The parsed date.\n    \"\"\"\n    if re.match(r\"\\d{4}-\\d{2}-\\d{2}\", date_string):\n        # Then it is in YYYY-MM-DD format\n        date = Date.fromisoformat(date_string)\n    elif re.match(r\"\\d{4}-\\d{2}\", date_string):\n        # Then it is in YYYY-MM format\n        # Assign a random day since days are not rendered in the CV\n        date = Date.fromisoformat(f\"{date_string}-01\")\n    elif re.match(r\"\\d{4}\", date_string):\n        # Then it is in YYYY format\n        # Then keep it as an integer\n        date = int(date_string)\n    else:\n        raise ValueError(\n            f'The date string \"{date_string}\" is not in YYYY-MM-DD, YYYY-MM, or YYYY'\n            \" format.\"\n        )\n\n    if isinstance(date, Date):\n        # Then it means the date is a Date object, so check if it is a past date:\n        if date &gt; Date.today():\n            raise ValueError(\n                f'The date \"{date_string}\" is in the future. Please check the dates.'\n            )\n\n    return date\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.compute_time_span_string","title":"<code>compute_time_span_string(start_date, end_date)</code>","text":"<p>Compute the time span between two dates and return a string that represents it.</p> Example <pre><code>compute_time_span_string(Date(2022,9,24), Date(2025,2,12))\n</code></pre> <p>will return:</p> <p><code>\"2 years 5 months\"</code></p> <p>Parameters:</p> <ul> <li> <code>start_date</code>             (<code>date | int</code>)         \u2013          <p>The start date.</p> </li> <li> <code>end_date</code>             (<code>date | int</code>)         \u2013          <p>The end date.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The time span string.</p> </li> </ul> Source code in <code>rendercv/data_model.py</code> <pre><code>def compute_time_span_string(start_date: Date | int, end_date: Date | int) -&gt; str:\n    \"\"\"Compute the time span between two dates and return a string that represents it.\n\n    Example:\n        ```python\n        compute_time_span_string(Date(2022,9,24), Date(2025,2,12))\n        ```\n\n        will return:\n\n        `#!python \"2 years 5 months\"`\n\n    Args:\n        start_date (Date | int): The start date.\n        end_date (Date | int): The end date.\n\n    Returns:\n        str: The time span string.\n    \"\"\"\n    # check if the types of start_date and end_date are correct:\n    if not isinstance(start_date, (Date, int)):\n        raise TypeError(\"start_date is not a Date object or an integer!\")\n    if not isinstance(end_date, (Date, int)):\n        raise TypeError(\"end_date is not a Date object or an integer!\")\n\n    # calculate the number of days between start_date and end_date:\n    if isinstance(start_date, Date) and isinstance(end_date, Date):\n        timespan_in_days = (end_date - start_date).days\n    elif isinstance(start_date, Date) and isinstance(end_date, int):\n        timespan_in_days = (Date(end_date, 1, 1) - start_date).days\n    elif isinstance(start_date, int) and isinstance(end_date, Date):\n        timespan_in_days = (end_date - Date(start_date, 1, 1)).days\n    elif isinstance(start_date, int) and isinstance(end_date, int):\n        timespan_in_days = (end_date - start_date) * 365\n\n    if timespan_in_days &lt; 0:\n        raise ValueError(\n            '\"start_date\" can not be after \"end_date\". Please check the dates.'\n        )\n\n    # calculate the number of years between start_date and end_date:\n    how_many_years = timespan_in_days // 365\n    if how_many_years == 0:\n        how_many_years_string = None\n    elif how_many_years == 1:\n        how_many_years_string = \"1 year\"\n    else:\n        how_many_years_string = f\"{how_many_years} years\"\n\n    # calculate the number of months between start_date and end_date:\n    how_many_months = round((timespan_in_days % 365) / 30)\n    if how_many_months &lt;= 1:\n        how_many_months_string = \"1 month\"\n    else:\n        how_many_months_string = f\"{how_many_months} months\"\n\n    # combine howManyYearsString and howManyMonthsString:\n    if how_many_years_string is None:\n        timespan_string = how_many_months_string\n    else:\n        timespan_string = f\"{how_many_years_string} {how_many_months_string}\"\n\n    return timespan_string\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.format_date","title":"<code>format_date(date)</code>","text":"<p>Formats a date to a string in the following format: \"Jan. 2021\".</p> <p>It uses month abbreviations, taken from Yale University Library.</p> Example <p><pre><code>format_date(Date(2024,5,1))\n</code></pre> will return</p> <p><code>\"May 2024\"</code></p> <p>Parameters:</p> <ul> <li> <code>date</code>             (<code>date</code>)         \u2013          <p>The date to format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The formatted date.</p> </li> </ul> Source code in <code>rendercv/data_model.py</code> <pre><code>def format_date(date: Date) -&gt; str:\n    \"\"\"Formats a date to a string in the following format: \"Jan. 2021\".\n\n    It uses month abbreviations, taken from\n    [Yale University Library](https://web.library.yale.edu/cataloging/months).\n\n    Example:\n        ```python\n        format_date(Date(2024,5,1))\n        ```\n        will return\n\n        `#!python \"May 2024\"`\n\n    Args:\n        date (Date): The date to format.\n\n    Returns:\n        str: The formatted date.\n    \"\"\"\n    if not isinstance(date, (Date, int)):\n        raise TypeError(\"date is not a Date object or an integer!\")\n\n    if isinstance(date, int):\n        # Then it means the user only provided the year, so just return the year\n        return str(date)\n\n    # Month abbreviations,\n    # taken from: https://web.library.yale.edu/cataloging/months\n    abbreviations_of_months = [\n        \"Jan.\",\n        \"Feb.\",\n        \"Mar.\",\n        \"Apr.\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"Aug.\",\n        \"Sept.\",\n        \"Oct.\",\n        \"Nov.\",\n        \"Dec.\",\n    ]\n\n    month = int(date.strftime(\"%m\"))\n    monthAbbreviation = abbreviations_of_months[month - 1]\n    year = date.strftime(\"%Y\")\n    date_string = f\"{monthAbbreviation} {year}\"\n\n    return date_string\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.generate_json_schema","title":"<code>generate_json_schema(output_directory)</code>","text":"<p>Generate the JSON schema of the data model and save it to a file.</p> <p>Parameters:</p> <ul> <li> <code>output_directory</code>             (<code>str</code>)         \u2013          <p>The output directory to save the schema.</p> </li> </ul> Source code in <code>rendercv/data_model.py</code> <pre><code>def generate_json_schema(output_directory: str) -&gt; str:\n    \"\"\"Generate the JSON schema of the data model and save it to a file.\n\n    Args:\n        output_directory (str): The output directory to save the schema.\n    \"\"\"\n\n    class RenderCVSchemaGenerator(GenerateJsonSchema):\n        def generate(self, schema, mode=\"validation\"):\n            json_schema = super().generate(schema, mode=mode)\n            json_schema[\"title\"] = \"RenderCV Input\"\n\n            # remove the description of the class (RenderCVDataModel)\n            del json_schema[\"description\"]\n\n            # add $id\n            json_schema[\n                \"$id\"\n            ] = \"https://raw.githubusercontent.com/sinaatalay/rendercv/main/schema.json\"\n\n            # add $schema\n            json_schema[\"$schema\"] = \"http://json-schema.org/draft-07/schema#\"\n\n            # Loop through $defs and remove docstring descriptions and fix optional\n            # fields\n            for key, value in json_schema[\"$defs\"].items():\n                # Don't allow additional properties\n                value[\"additionalProperties\"] = False\n\n                # I don't want the docstrings in the schema, so remove them:\n                if \"description\" in value and \"This class\" in value[\"description\"]:\n                    del value[\"description\"]\n\n                # If a type is optional, then Pydantic sets the type to a list of two\n                # types, one of which is null. The null type can be removed since we\n                # already have the required field. Moreover, we would like to warn\n                # users if they provide null values. They can remove the fields if they\n                # don't want to provide them.\n                null_type_dict = {}\n                null_type_dict[\"type\"] = \"null\"\n                for field in value[\"properties\"].values():\n                    if \"anyOf\" in field:\n                        if (\n                                len(field[\"anyOf\"]) == 2\n                                and null_type_dict in field[\"anyOf\"]\n                        ):\n                            field[\"allOf\"] = [field[\"anyOf\"][0]]\n                            del field[\"anyOf\"]\n\n                # In date field, we both accept normal strings and Date objects. They\n                # are both strings, therefore, if user provides a Date object, then\n                # JSON schema will complain that it matches two different types.\n                # Remember that all of the anyOfs are changed to oneOfs. Only one of\n                # the types can be matched. Therefore, we remove the first type, which\n                # is the string with the YYYY-MM-DD format.\n                if (\n                        \"date\" in value[\"properties\"]\n                        and \"anyOf\" in value[\"properties\"][\"date\"]\n                ):\n                    del value[\"properties\"][\"date\"][\"anyOf\"][0]\n\n            return json_schema\n\n    schema = RenderCVDataModel.model_json_schema(\n        schema_generator=RenderCVSchemaGenerator\n    )\n    schema = json.dumps(schema, indent=2)\n\n    # Change all anyOf to oneOf\n    schema = schema.replace('\"anyOf\"', '\"oneOf\"')\n\n    path_to_schema = os.path.join(output_directory, \"schema.json\")\n    with open(path_to_schema, \"w\") as f:\n        f.write(schema)\n\n    return path_to_schema\n</code></pre>"},{"location":"api_reference/data_model/#rendercv.data_model.read_input_file","title":"<code>read_input_file(file_path)</code>","text":"<p>Read the input file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>             (<code>str</code>)         \u2013          <p>The path to the input file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>RenderCVDataModel</code> )        \u2013          <p>The input file as a string.</p> </li> </ul> Source code in <code>rendercv/data_model.py</code> <pre><code>def read_input_file(file_path: str) -&gt; RenderCVDataModel:\n    \"\"\"Read the input file.\n\n    Args:\n        file_path (str): The path to the input file.\n\n    Returns:\n        str: The input file as a string.\n    \"\"\"\n    start_time = time.time()\n    logger.info(f\"Reading and validating the input file {file_path} has started.\")\n\n    # check if the file exists:\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file {file_path} doesn't exist.\")\n\n    # check the file extension:\n    accepted_extensions = [\".yaml\", \".yml\", \".json\", \".json5\"]\n    if not any(file_path.endswith(extension) for extension in accepted_extensions):\n        raise ValueError(\n            f\"The file {file_path} doesn't have an accepted extension!\"\n            f\" Accepted extensions are: {accepted_extensions}\"\n        )\n\n    with open(file_path) as file:\n        yaml = YAML()\n        raw_json = yaml.load(file)\n\n    data = RenderCVDataModel(**raw_json)\n\n    end_time = time.time()\n    time_taken = end_time - start_time\n    logger.info(\n        f\"Reading and validating the input file {file_path} has finished in\"\n        f\" {time_taken:.2f} s.\"\n    )\n    return data\n</code></pre>"},{"location":"api_reference/rendering/","title":"Rendering","text":"<p>This module implements LaTeX file generation and LaTeX runner utilities for RenderCV.</p>"},{"location":"api_reference/rendering/#rendercv.rendering.markdown_to_latex","title":"<code>markdown_to_latex(markdown_string)</code>","text":"<p>Convert a markdown string to LaTeX.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>markdown_to_latex(\"This is a **bold** text with an [*italic link*](https://google.com).\")\n</code></pre> <p>will return:</p> <p><code>\"This is a \\textbf{bold} text with a \\href{https://google.com}{\\textit{link}}.\"</code></p> <p>Parameters:</p> <ul> <li> <code>markdown_string</code>             (<code>str</code>)         \u2013          <p>The markdown string to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The LaTeX string.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def markdown_to_latex(markdown_string: str) -&gt; str:\n    \"\"\"Convert a markdown string to LaTeX.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        markdown_to_latex(\"This is a **bold** text with an [*italic link*](https://google.com).\")\n        ```\n\n        will return:\n\n        `#!pytjon \"This is a \\\\textbf{bold} text with a \\\\href{https://google.com}{\\\\textit{link}}.\"`\n\n    Args:\n        markdown_string (str): The markdown string to convert.\n\n    Returns:\n        str: The LaTeX string.\n    \"\"\"\n    if not isinstance(markdown_string, str):\n        raise ValueError(\"markdown_to_latex should only be used on strings!\")\n\n    # convert links\n    links = re.findall(r\"\\[([^\\]\\[]*)\\]\\((.*?)\\)\", markdown_string)\n    if links is not None:\n        for link in links:\n            link_text = link[0]\n            link_url = link[1]\n\n            old_link_string = f\"[{link_text}]({link_url})\"\n            new_link_string = \"\\\\href{\" + link_url + \"}{\" + link_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_link_string, new_link_string)\n\n    # convert bold\n    bolds = re.findall(r\"\\*\\*([^\\*]*)\\*\\*\", markdown_string)\n    if bolds is not None:\n        for bold_text in bolds:\n            old_bold_text = f\"**{bold_text}**\"\n            new_bold_text = \"\\\\textbf{\" + bold_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_bold_text, new_bold_text)\n\n    # convert italic\n    italics = re.findall(r\"\\*([^\\*]*)\\*\", markdown_string)\n    if italics is not None:\n        for italic_text in italics:\n            old_italic_text = f\"*{italic_text}*\"\n            new_italic_text = \"\\\\textit{\" + italic_text + \"}\"\n\n            markdown_string = markdown_string.replace(old_italic_text, new_italic_text)\n\n    latex_string = markdown_string\n\n    return latex_string\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.markdown_link_to_url","title":"<code>markdown_link_to_url(value)</code>","text":"<p>Convert a markdown link to a normal string URL.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>markdown_link_to_url(\"[Google](https://google.com)\")\n</code></pre> <p>will return:</p> <p><code>\"https://google.com\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The markdown link to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The URL as a string.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def markdown_link_to_url(value: str) -&gt; str:\n    \"\"\"Convert a markdown link to a normal string URL.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        markdown_link_to_url(\"[Google](https://google.com)\")\n        ```\n\n        will return:\n\n        `#!python \"https://google.com\"`\n\n    Args:\n        value (str): The markdown link to convert.\n\n    Returns:\n        str: The URL as a string.\n    \"\"\"\n    if not isinstance(value, str):\n        raise ValueError(\"markdown_to_latex should only be used on strings!\")\n\n    link = re.search(r\"\\[(.*)\\]\\((.*?)\\)\", value)\n    if link is not None:\n        url = link.groups()[1]\n        if url == \"\":\n            raise ValueError(f\"The markdown link {value} is empty!\")\n        return url\n    else:\n        raise ValueError(\"markdown_link_to_url should only be used on markdown links!\")\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.make_it_something","title":"<code>make_it_something(value, something, match_str=None)</code>","text":"<p>Make the matched parts of the string something. If the match_str is None, the whole string will be made something.</p> Warning <p>This function shouldn't be used directly. Use make_it_bold, make_it_underlined, or make_it_italic instead.</p> Source code in <code>rendercv/rendering.py</code> <pre><code>def make_it_something(\n        value: str, something: str, match_str: Optional[str] = None\n) -&gt; str:\n    \"\"\"Make the matched parts of the string something. If the match_str is None, the\n    whole string will be made something.\n\n    Warning:\n        This function shouldn't be used directly. Use\n        [make_it_bold](rendering.md#rendercv.rendering.make_it_bold),\n        [make_it_underlined](rendering.md#rendercv.rendering.make_it_underlined), or\n        [make_it_italic](rendering.md#rendercv.rendering.make_it_italic) instead.\n    \"\"\"\n    if not isinstance(value, str):\n        raise ValueError(f\"{something} should only be used on strings!\")\n\n    if match_str is not None and not isinstance(match_str, str):\n        raise ValueError(\"The string to match should be a string!\")\n\n    if match_str is None:\n        return f\"\\\\{something}{{{value}}}\"\n\n    if match_str in value:\n        value = value.replace(match_str, f\"\\\\{something}{{{match_str}}}\")\n        return value\n    else:\n        return value\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.make_it_bold","title":"<code>make_it_bold(value, match_str=None)</code>","text":"<p>Make the matched parts of the string bold. If the match_str is None, the whole string will be made bold.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>make_it_bold(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\textbf{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make bold.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def make_it_bold(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string bold. If the match_str is None, the whole\n    string will be made bold.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        make_it_bold(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\textbf{Hello} World!\"`\n\n    Args:\n        value (str): The string to make bold.\n        match_str (str): The string to match.\n    \"\"\"\n    return make_it_something(value, \"textbf\", match_str)\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.make_it_underlined","title":"<code>make_it_underlined(value, match_str=None)</code>","text":"<p>Make the matched parts of the string underlined. If the match_str is None, the whole string will be made underlined.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>make_it_underlined(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\underline{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make underlined.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def make_it_underlined(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string underlined. If the match_str is None, the\n    whole string will be made underlined.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        make_it_underlined(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\underline{Hello} World!\"`\n\n    Args:\n        value (str): The string to make underlined.\n        match_str (str): The string to match.\n    \"\"\"\n    return make_it_something(value, \"underline\", match_str)\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.make_it_italic","title":"<code>make_it_italic(value, match_str=None)</code>","text":"<p>Make the matched parts of the string italic. If the match_str is None, the whole string will be made italic.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>make_it_italic(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\textit{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to make italic.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def make_it_italic(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string italic. If the match_str is None, the whole\n    string will be made italic.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        make_it_italic(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\textit{Hello} World!\"`\n\n    Args:\n        value (str): The string to make italic.\n        match_str (str): The string to match.\n    \"\"\"\n    return make_it_something(value, \"textit\", match_str)\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.make_it_nolinebreak","title":"<code>make_it_nolinebreak(value, match_str=None)</code>","text":"<p>Make the matched parts of the string non line breakable. If the match_str is None, the whole string will be made nonbreakable.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>make_it_nolinebreak(\"Hello World!\", \"Hello\")\n</code></pre> <p>will return:</p> <p><code>\"\\mbox{Hello} World!\"</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>The string to disable line breaks.</p> </li> <li> <code>match_str</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The string to match.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def make_it_nolinebreak(value: str, match_str: Optional[str] = None) -&gt; str:\n    \"\"\"Make the matched parts of the string non line breakable. If the match_str is\n    None, the whole string will be made nonbreakable.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        make_it_nolinebreak(\"Hello World!\", \"Hello\")\n        ```\n\n        will return:\n\n        `#!python \"\\\\mbox{Hello} World!\"`\n\n    Args:\n        value (str): The string to disable line breaks.\n        match_str (str): The string to match.\n    \"\"\"\n    return make_it_something(value, \"mbox\", match_str)\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.abbreviate_name","title":"<code>abbreviate_name(name)</code>","text":"<p>Abbreviate a name by keeping the first letters of the first names.</p> <p>This function is used as a Jinja2 filter.</p> Example <pre><code>abbreviate_name(\"John Doe\")\n</code></pre> <p>will return:</p> <p><code>\"J. Doe\"</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name to abbreviate.</p> </li> </ul> <p>Returns:     str: The abbreviated name.</p> Source code in <code>rendercv/rendering.py</code> <pre><code>def abbreviate_name(name: list[str]) -&gt; str:\n    \"\"\"Abbreviate a name by keeping the first letters of the first names.\n\n    This function is used as a Jinja2 filter.\n\n    Example:\n        ```python\n        abbreviate_name(\"John Doe\")\n        ```\n\n        will return:\n\n        `#!python \"J. Doe\"`\n\n    Args:\n        name (str): The name to abbreviate.\n    Returns:\n        str: The abbreviated name.\n    \"\"\"\n    first_names = name.split(\" \")[:-1]\n    first_names_initials = [first_name[0] + \".\" for first_name in first_names]\n    last_name = name.split(\" \")[-1]\n    abbreviated_name = \" \".join(first_names_initials) + \" \" + last_name\n\n    return abbreviated_name\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.divide_length_by","title":"<code>divide_length_by(length, divider)</code>","text":"<p>Divide a length by a number.</p> <p>Length is a string with the following regex pattern: <code>\\d+\\.?\\d* *(cm|in|pt|mm|ex|em)</code></p> Source code in <code>rendercv/rendering.py</code> <pre><code>def divide_length_by(length: str, divider: float) -&gt; str:\n    r\"\"\"Divide a length by a number.\n\n    Length is a string with the following regex pattern: `\\d+\\.?\\d* *(cm|in|pt|mm|ex|em)`\n    \"\"\"\n    # Get the value as a float and the unit as a string:\n    value = re.search(r\"\\d+\\.?\\d*\", length).group()  # type: ignore\n    unit = re.findall(r\"[^\\d\\.\\s]+\", length)[0]\n\n    return str(float(value) / divider) + \" \" + unit\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.get_today","title":"<code>get_today()</code>","text":"<p>Return today's date in the format of \"Month Year\".</p> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>Today's date.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def get_today() -&gt; str:\n    \"\"\"Return today's date in the format of \"Month Year\".\n\n    Returns:\n        str: Today's date.\n    \"\"\"\n\n    today = date.today()\n    return today.strftime(\"%B %Y\")\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.get_path_to_font_directory","title":"<code>get_path_to_font_directory(font_name)</code>","text":"<p>Return the path to the fonts directory.</p> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The path to the fonts directory.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def get_path_to_font_directory(font_name: str) -&gt; str:\n    \"\"\"Return the path to the fonts directory.\n\n    Returns:\n        str: The path to the fonts directory.\n    \"\"\"\n    return str(files(\"rendercv\").joinpath(\"templates\", \"fonts\", font_name))\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.render_template","title":"<code>render_template(cv, template='cv', suffix='CV', output_path=None)</code>","text":"<p>Render the template using the given data.</p> <p>Parameters:</p> <ul> <li> <code>cv</code>             (<code>RenderCVDataModel</code>)         \u2013          <p>The data to use to render the template.</p> </li> <li> <code>template</code>             (<code>str</code>, default:                 <code>'cv'</code> )         \u2013          <p>template to render</p> </li> <li> <code>suffix</code>             (<code>str</code>, default:                 <code>'CV'</code> )         \u2013          <p>result file suffix</p> </li> <li> <code>output_path</code>             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>The path to the rendered LaTeX file.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def render_template(cv: RenderCVDataModel, template: str = \"cv\", suffix: str = \"CV\",\n                    output_path: Optional[str] = None) -&gt; str:\n    \"\"\"Render the template using the given data.\n\n    Args:\n        cv (RenderCVDataModel): The data to use to render the template.\n        template: template to render\n        suffix: result file suffix\n        output_path:\n\n    Returns:\n        str: The path to the rendered LaTeX file.\n    \"\"\"\n    start_time = time.time()\n    logger.info(\"Rendering the LaTeX file has started.\")\n\n    # create a Jinja2 environment:\n    theme = cv.design.theme\n    environment = Environment(\n        loader=PackageLoader(\"rendercv\", os.path.join(\"templates\", theme)),\n        trim_blocks=True,\n        lstrip_blocks=True,\n    )\n\n    # add new functions to the environment:\n    environment.globals.update(str=str)\n\n    # set custom delimiters for LaTeX templating:\n    environment.block_start_string = \"((*\"\n    environment.block_end_string = \"*))\"\n    environment.variable_start_string = \"&lt;&lt;\"\n    environment.variable_end_string = \"&gt;&gt;\"\n    environment.comment_start_string = \"((#\"\n    environment.comment_end_string = \"#))\"\n\n    # add custom filters:\n    environment.filters[\"markdown_to_latex\"] = markdown_to_latex\n    environment.filters[\"markdown_link_to_url\"] = markdown_link_to_url\n    environment.filters[\"make_it_bold\"] = make_it_bold\n    environment.filters[\"make_it_underlined\"] = make_it_underlined\n    environment.filters[\"make_it_italic\"] = make_it_italic\n    environment.filters[\"make_it_nolinebreak\"] = make_it_nolinebreak\n    environment.filters[\"make_it_something\"] = make_it_something\n    environment.filters[\"divide_length_by\"] = divide_length_by\n    environment.filters[\"abbreviate_name\"] = abbreviate_name\n\n    # load the template:\n    template = environment.get_template(os.path.join(template, f\"{theme}.tex.j2\"))\n\n    design: Design = cv.design\n    theme_options: ClassicThemeOptions = cv.design.options\n    output_latex_file = template.render(\n        cv=cv.cv,\n        design=design,\n        theme_options=theme_options,\n        today=get_today(),\n    )\n\n    # Create an output file and write the rendered LaTeX code to it:\n    if output_path is None:\n        output_path = os.getcwd()\n\n    output_folder = os.path.join(output_path, \"output\")\n    file_name = cv.cv.name.replace(\" \", \"_\") + f\"_{suffix}.tex\"\n    output_file_path = os.path.join(output_folder, file_name)\n    os.makedirs(os.path.dirname(output_file_path), exist_ok=True)\n    with open(output_file_path, \"w\") as file:\n        file.write(output_latex_file)\n\n    # Copy the fonts directory to the output directory:\n    # Remove the old fonts directory if it exists:\n    if os.path.exists(os.path.join(os.path.dirname(output_file_path), \"fonts\")):\n        shutil.rmtree(os.path.join(os.path.dirname(output_file_path), \"fonts\"))\n\n    font_directory = get_path_to_font_directory(cv.design.font)\n    output_fonts_directory = os.path.join(os.path.dirname(output_file_path), \"fonts\")\n    shutil.copytree(\n        font_directory,\n        output_fonts_directory,\n        dirs_exist_ok=True,\n    )\n\n    # Copy auxiliary files to the output directory (if there is any):\n    output_directory = os.path.dirname(output_file_path)\n    theme_directory = str(files(\"rendercv\").joinpath(\"templates\", theme))\n    for file_name in os.listdir(theme_directory):\n        if file_name.endswith(\".cls\"):\n            shutil.copy(\n                os.path.join(theme_directory, file_name),\n                output_directory,\n            )\n\n    end_time = time.time()\n    time_taken = end_time - start_time\n    logger.info(\n        f\"Rendering the LaTeX file ({output_file_path}) has finished in\"\n        f\" {time_taken:.2f} s.\"\n    )\n\n    return output_file_path\n</code></pre>"},{"location":"api_reference/rendering/#rendercv.rendering.run_latex","title":"<code>run_latex(latex_file_path)</code>","text":"<p>Run TinyTeX with the given LaTeX file and generate a PDF.</p> <p>Parameters:</p> <ul> <li> <code>latex_file_path</code>             (<code>str</code>)         \u2013          <p>The path to the LaTeX file to compile.</p> </li> </ul> Source code in <code>rendercv/rendering.py</code> <pre><code>def run_latex(latex_file_path: str) -&gt; str:\n    \"\"\"\n    Run TinyTeX with the given LaTeX file and generate a PDF.\n\n    Args:\n        latex_file_path (str): The path to the LaTeX file to compile.\n    \"\"\"\n    start_time = time.time()\n    logger.info(\"Running TinyTeX to generate the PDF has started.\")\n    latex_file_name = os.path.basename(latex_file_path)\n    latex_file_path = os.path.normpath(latex_file_path)\n\n    # check if the file exists:\n    if not os.path.exists(latex_file_path):\n        raise FileNotFoundError(f\"The file {latex_file_path} doesn't exist!\")\n\n    output_file_name = latex_file_name.replace(\".tex\", \".pdf\")\n    output_file_path = os.path.join(os.path.dirname(latex_file_path), output_file_name)\n\n    if sys.platform == \"win32\":\n        # Windows\n        executable = str(\n            files(\"rendercv\").joinpath(\n                \"vendor\", \"TinyTeX\", \"bin\", \"windows\", \"lualatex.exe\"\n            )\n        )\n\n    elif sys.platform == \"linux\" or sys.platform == \"linux2\":\n        # Linux\n        executable = str(\n            files(\"rendercv\").joinpath(\n                \"vendor\", \"TinyTeX\", \"bin\", \"x86_64-linux\", \"lualatex\"\n            )\n        )\n    elif sys.platform == \"darwin\":\n        # MacOS\n        executable = str(\n            files(\"rendercv\").joinpath(\n                \"vendor\", \"TinyTeX\", \"bin\", \"universal-darwin\", \"lualatex\"\n            )\n        )\n    else:\n        raise OSError(f\"Unknown OS {os.name}!\")\n\n    # Check if the executable exists:\n    if not os.path.exists(executable):\n        raise FileNotFoundError(\n            f\"The TinyTeX executable ({executable}) doesn't exist! Please install\"\n            \" RenderCV again.\"\n        )\n\n    # Run TinyTeX:\n    def run():\n        with subprocess.Popen(\n                [\n                    executable,\n                    f\"{latex_file_name}\",\n                ],\n                cwd=os.path.dirname(latex_file_path),\n                stdout=subprocess.PIPE,\n                stdin=subprocess.DEVNULL,  # don't allow TinyTeX to ask for user input\n                text=True,\n                encoding=\"utf-8\",\n        ) as latex_process:\n            output, error = latex_process.communicate()\n\n            if latex_process.returncode != 0:\n                # Find the error line:\n                for line in output.split(\"\\n\"):\n                    if line.startswith(\"! \"):\n                        error_line = line.replace(\"! \", \"\")\n                        break\n\n                raise RuntimeError(\n                    \"Running TinyTeX has failed with the following error:\",\n                    f\"{error_line}\",\n                    \"If you can't solve the problem, please try to re-install RenderCV,\"\n                    \" or open an issue on GitHub.\",\n                )\n\n    run()\n    run()  # run twice for cross-references\n\n    # check if the PDF file is generated:\n    if not os.path.exists(output_file_path):\n        raise FileNotFoundError(\n            f\"The PDF file {output_file_path} couldn't be generated! If you can't\"\n            \" solve the problem, please try to re-install RenderCV, or open an issue\"\n            \" on GitHub.\"\n        )\n\n    # remove the unnecessary files:\n    for file_name in os.listdir(os.path.dirname(latex_file_path)):\n        if (\n                file_name.endswith(\".aux\")\n                or file_name.endswith(\".log\")\n                or file_name.endswith(\".out\")\n        ):\n            os.remove(os.path.join(os.path.dirname(latex_file_path), file_name))\n\n    end_time = time.time()\n    time_taken = end_time - start_time\n    logger.info(\n        f\"Running TinyTeX to generate the PDF ({output_file_path}) has finished in\"\n        f\" {time_taken:.2f} s.\"\n    )\n\n    return output_file_path\n</code></pre>"}]}